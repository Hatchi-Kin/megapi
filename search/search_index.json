{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MegaPi","text":"<p>Welcome to MegaPi, the dynamic backend API powering the music sim web application. Engineered to revolutionize the way users explore music, MegaPi delivers personalized song recommendations with unparalleled accuracy. At its core, MegaPi harnesses the power of the Milvus vector database and sophisticated single feature vectors, crafted using an Essentia CNN specifically trained for music genre classification. Coupled with the robust MinIO object storage system, MegaPi provides a seamless and innovative solution for navigating through an extensive music library, ensuring every user experience is both unique and engaging.</p>"},{"location":"#runs-in-a-docker-container","title":"Runs in a Docker container","text":"<pre><code>docker compose up -d\n</code></pre> <pre><code>docker ps --format 'table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Status}}\\t{{.Names}}'\n</code></pre> <pre><code>NAMES                           PORTS\n\nmegapi-megapi-1                 8000:8000\nmegapi-minio-1                  9000:9001\nmegapi-postgre-1                5432:5432\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <pre><code>.\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 docker-compose.yaml\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 core\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mtg_jamendo_genre.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 music.db\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 database.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 extract_openl3_embeddings.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 extract_openl3_embeddings.py\n\u2502\n\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 endpoints\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 index.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 services\n\u2502\n\u251c\u2500\u2500 gui\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 templates\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.html\n\u2502\n\u251c\u2500\u2500 models\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 favorites.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 milvus.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 minio.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 music.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 openl3.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 spotinite.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 uploaded.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 users.py\n\u2502\n\u251c\u2500\u2500 routes\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 auth.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 favorites.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 lyrics.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 milvus.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 minio.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 monitoring.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 music.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 openl3.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 spotinite.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 uploaded.py\n\u2502\n\u251c\u2500\u2500 services\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 auth.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 favorites.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 lyrics.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 milvus.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 minio.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 monitoring.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 openl3.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 spotinite.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 uploaded.py\n\u2502\n\u251c\u2500\u2500 site\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 tests\n \u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n \u00a0\u00a0 \u251c\u2500\u2500 test_auth.py\n \u00a0\u00a0 \u251c\u2500\u2500 test_files.py\n \u00a0\u00a0 \u251c\u2500\u2500 test_milvus.py\n \u00a0\u00a0 \u2514\u2500\u2500 test_minio.py\n</code></pre>"},{"location":"#mkdocs-commands","title":"MkDocs Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"endpoints/auth/","title":"Documentation for <code>routes/auth.py</code>","text":"<p>This module contains the endpoints for the authentication service. It provides routes for user registration, login, and logout and other related operations.</p>"},{"location":"endpoints/auth/#routes.auth.delete_user","title":"<code>delete_user(user_id, current_user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Delete a user by their user ID.</p> <ul> <li>user_id: int - The ID of the user to delete.</li> <li>current_user: User - The current authenticated user attempting the deletion.</li> <li>db: Session - The database session dependency.</li> <li>return: Returns a dictionary with a detail message on successful deletion.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.delete(\"/users/{user_id}\", tags=[\"users\"], response_model=dict)\ndef delete_user(\n    user_id: int, current_user=Depends(login_manager), db: Session = Depends(get_db)\n):\n    \"\"\"\n    Delete a user by their user ID.\n\n    - **user_id**: int - The ID of the user to delete.\n    - **current_user**: User - The current authenticated user attempting the deletion.\n    - **db**: Session - The database session dependency.\n    - **return**: Returns a dictionary with a detail message on successful deletion.\n    \"\"\"\n    if not current_user:\n        raise InvalidCredentialsException(detail=\"Invalid credentials\")\n    if current_user.id != 1:\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    db.delete(user)\n    db.commit()\n    return {\"detail\": \"User deleted\"}\n</code></pre>"},{"location":"endpoints/auth/#routes.auth.index","title":"<code>index()</code>","text":"<p>Render a front-end GUI for testing signup/login functionality.</p> <ul> <li>return: Returns an HTMLResponse containing the content of the index.html page.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.get(\"/gui\", tags=[\"auth gui\"], response_class=HTMLResponse)\ndef index():\n    \"\"\"\n    Render a front-end GUI for testing signup/login functionality.\n\n    - **return**: Returns an HTMLResponse containing the content of the index.html page.\n    \"\"\"\n    file_path = os.path.join(\"gui\", \"templates\", \"index.html\")\n    with open(file_path, \"r\") as f:\n        return HTMLResponse(content=f.read())\n</code></pre>"},{"location":"endpoints/auth/#routes.auth.list_users","title":"<code>list_users(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>List all users.</p> <ul> <li>user: User - The current authenticated user (unused in this function).</li> <li>db: Session - The database session dependency.</li> <li>return: Returns a list of dictionaries, each representing a user with their id and email.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.get(\"/users\", tags=[\"users\"], response_model=list)\ndef list_users(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    List all users.\n\n    - **user**: User - The current authenticated user (unused in this function).\n    - **db**: Session - The database session dependency.\n    - **return**: Returns a list of dictionaries, each representing a user with their id and email.\n    \"\"\"\n    users = db.query(User).all()\n    users = [{\"id\": user.id, \"email\": user.email} for user in users]\n    return users\n</code></pre>"},{"location":"endpoints/auth/#routes.auth.login","title":"<code>login(data=Depends())</code>","text":"<p>Authenticate a user and return an access token.</p> <ul> <li>data: OAuth2PasswordRequestForm - A form data model including username (email) and password.</li> <li>return: Returns a TokenData object containing the access token and token type.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.post(\"/token\", tags=[\"users\"], response_model=TokenData)\ndef login(data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"\n    Authenticate a user and return an access token.\n\n    - **data**: OAuth2PasswordRequestForm - A form data model including username (email) and password.\n    - **return**: Returns a TokenData object containing the access token and token type.\n    \"\"\"\n    email = data.username\n    password = data.password\n    user = get_user(email)\n    if not user or not bcrypt.checkpw(\n        password.encode(\"utf-8\"), user.hashed_password.encode(\"utf-8\")\n    ):\n        raise InvalidCredentialsException\n    access_token_expires = timedelta(minutes=DEFAULT_SETTINGS.access_token_expire_minutes)\n    access_token = login_manager.create_access_token(\n        data=dict(sub=email), expires=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"endpoints/auth/#routes.auth.private_route","title":"<code>private_route(user=Depends(login_manager))</code>","text":"<p>A private route that requires authentication.</p> <ul> <li>user: User - The current authenticated user.</li> <li>return: Returns a dictionary with a welcome message for the authenticated user.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.get(\"/private\", tags=[\"users\"], summary=\"A private route that requires authentication.\", response_model=dict)\ndef private_route(user=Depends(login_manager)):\n    \"\"\"\n    A private route that requires authentication.\n\n    - **user**: User - The current authenticated user.\n    - **return**: Returns a dictionary with a welcome message for the authenticated user.\n    \"\"\"\n    return {\"detail\": f\"Welcome {user.email}, you are authenticated\"}\n</code></pre>"},{"location":"endpoints/auth/#routes.auth.read_users_me","title":"<code>read_users_me(user=Depends(login_manager))</code>  <code>async</code>","text":"<p>Get the current authenticated user.</p> <ul> <li>user: User - The current authenticated user from the session.</li> <li>return: Returns the user object of the currently authenticated user.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.get(\"/users/me\", tags=[\"users\"])\nasync def read_users_me(user: User = Depends(login_manager)):\n    \"\"\"\n    Get the current authenticated user.\n\n    - **user**: User - The current authenticated user from the session.\n    - **return**: Returns the user object of the currently authenticated user.\n    \"\"\"\n    return user\n</code></pre>"},{"location":"endpoints/auth/#routes.auth.register","title":"<code>register(user, db=Depends(get_db))</code>","text":"<p>Register a new user with the provided email and password.</p> <ul> <li>user: UserCreate - A user creation object containing the email and password.</li> <li>db: Session - The database session dependency.</li> <li>return: Returns a dictionary with a detail message on successful registration.</li> </ul> Source code in <code>routes/auth.py</code> <pre><code>@router.post(\"/register\", tags=[\"users\"], response_model=dict)\ndef register(user: UserCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Register a new user with the provided email and password.\n\n    - **user**: UserCreate - A user creation object containing the email and password.\n    - **db**: Session - The database session dependency.\n    - **return**: Returns a dictionary with a detail message on successful registration.\n    \"\"\"\n    db_user = get_user(user.email)\n    if db_user:\n        raise HTTPException(\n            status_code=400, detail=\"A user with this email already exists\"\n        )\n    hashed_password = hash_password(user.password)\n    db_user = User(email=user.email, hashed_password=hashed_password)\n    db.add(db_user)\n    db.commit()\n    return {\"detail\": \"Successfully registered\"}\n</code></pre>"},{"location":"endpoints/favorites/","title":"Documentation for <code>routes/favorites.py</code>","text":"<p>This module contains the endpoints for the favorites service. It provides routes for adding, removing, and listing favorite songs for a user.</p>"},{"location":"endpoints/favorites/#routes.favorites.add_song_to_favorites","title":"<code>add_song_to_favorites(song, user=Depends(login_manager), db=Depends(get_db))</code>  <code>async</code>","text":"<p>Add a song to the authenticated user's list of favorites.</p> <ul> <li>song: SongPath - The path of the song to be added to favorites.</li> <li>user: User - The authenticated user who is adding the song to favorites.</li> <li>db: Session - The database session for querying and updating the database.</li> <li>return: Returns a message indicating the song was successfully added to favorites or if it was already in favorites.</li> </ul> Source code in <code>routes/favorites.py</code> <pre><code>@router.post(\"/add\", tags=[\"favorites\"])\nasync def add_song_to_favorites(song: SongPath, user: User = Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Add a song to the authenticated user's list of favorites.\n\n    - **song**: SongPath - The path of the song to be added to favorites.\n    - **user**: User - The authenticated user who is adding the song to favorites.\n    - **db**: Session - The database session for querying and updating the database.\n    - **return**: Returns a message indicating the song was successfully added to favorites or if it was already in favorites.\n    \"\"\"\n    user = db.merge(user)\n    db.refresh(user)\n\n    if len(user.favorites) &gt;= 9:\n        # Remove the oldest song from the favorites\n        user.favorites.pop(0)\n\n    music_id = get_song_id_by_filepath(db, song.file_path)\n    if not music_id:\n        raise HTTPException(status_code=404, detail=\"Song not found\")\n    music = db.query(MusicLibrary).get(music_id)\n\n    # Check if the song is already in the user's favorites\n    if music in user.favorites:\n        return {\"message\": \"Song is already in favorites\"}\n\n    user.favorites.append(music)\n    db.commit()\n    return {\"message\": \"Song added to favorites\"}\n</code></pre>"},{"location":"endpoints/favorites/#routes.favorites.delete_song_from_favorites","title":"<code>delete_song_from_favorites(song, user=Depends(login_manager), db=Depends(get_db))</code>  <code>async</code>","text":"<p>Remove a song from the authenticated user's list of favorites.</p> <ul> <li>song: SongPath - The path of the song to be removed from favorites.</li> <li>user: User - The authenticated user who is removing the song from favorites.</li> <li>db: Session - The database session for querying and updating the database.</li> <li>return: Returns a message indicating the song was successfully removed from favorites or if the song was not found in favorites.</li> </ul> Source code in <code>routes/favorites.py</code> <pre><code>@router.delete(\"/delete\", tags=[\"favorites\"])\nasync def delete_song_from_favorites(song: SongPath, user: User = Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Remove a song from the authenticated user's list of favorites.\n\n    - **song**: SongPath - The path of the song to be removed from favorites.\n    - **user**: User - The authenticated user who is removing the song from favorites.\n    - **db**: Session - The database session for querying and updating the database.\n    - **return**: Returns a message indicating the song was successfully removed from favorites or if the song was not found in favorites.\n    \"\"\"\n    user = db.merge(user)\n    db.refresh(user)\n    music_id = get_song_id_by_filepath(db, song.file_path)\n    if not music_id:\n        raise HTTPException(status_code=404, detail=\"Song not found\")\n    music = db.query(MusicLibrary).get(music_id)\n    for favorite in user.favorites:\n        if favorite.id == music.id:\n            user.favorites.remove(favorite)\n            db.commit()\n            return {\"message\": \"Song removed from favorites\"}\n    raise HTTPException(status_code=404, detail=\"Song not found in favorites\")\n</code></pre>"},{"location":"endpoints/favorites/#routes.favorites.get_favorites","title":"<code>get_favorites(user=Depends(login_manager), db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve the list of favorite songs for the authenticated user.</p> <ul> <li>user: User - The authenticated user whose favorites are to be retrieved.</li> <li>db: Session - The database session for querying the database.</li> <li>return: Returns a list of the user's favorite songs.</li> </ul> Source code in <code>routes/favorites.py</code> <pre><code>@router.get(\"/\", tags=[\"favorites\"])\nasync def get_favorites(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve the list of favorite songs for the authenticated user.\n\n    - **user**: User - The authenticated user whose favorites are to be retrieved.\n    - **db**: Session - The database session for querying the database.\n    - **return**: Returns a list of the user's favorite songs.\n    \"\"\"\n    # The merge() function is used to merge a detached object back into the session.\n    # It returns a new instance that represents the existing row in the DB.\n    # This is necessary because the 'user' object might have been created in a different session and we want to associate it with the current session.\n    user = db.merge(user)\n\n    # The refresh() function is used to update the attributes of the 'user' instance with the current data in the DB.\n    # This is necessary because the 'user' object might have stale data and we want to ensure we're working with the most recent data.\n    db.refresh(user)\n    return user.favorites\n</code></pre>"},{"location":"endpoints/lyrics/","title":"Documentation for <code>routes/lyrics.py</code>","text":"<p>This module contains the endpoints for the lyrics service. It provides routes for searching for lyrics by song title and artist, and for retrieving lyrics using <code>https://api.lyrics.ovh</code></p>"},{"location":"endpoints/lyrics/#routes.lyrics.get_random_row","title":"<code>get_random_row(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Fetches a random song from the music library along with its lyrics from the lyrics.ovh API.</p> <ul> <li>user: User - The authenticated user making the request.</li> <li>db: Session - The database session for querying the database.</li> <li>return: Returns a JSON object containing the song's ID, details, and lyrics.</li> </ul> Source code in <code>routes/lyrics.py</code> <pre><code>@router.get(\"/random-lyrics\", tags=[\"lyrics\"])\ndef get_random_row(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Fetches a random song from the music library along with its lyrics from the lyrics.ovh API.\n\n    - **user**: User - The authenticated user making the request.\n    - **db**: Session - The database session for querying the database.\n    - **return**: Returns a JSON object containing the song's ID, details, and lyrics.\n    \"\"\"\n    with db:\n        row = db.query(MusicLibrary).order_by(func.random()).first()\n        if row is None:\n            raise HTTPException(status_code=404, detail=\"No songs found in the library.\")\n        lyrics = fetch_lyrics(row.artist, row.title)\n        return {\"id\": row.id, \"row\": row, \"lyrics\": lyrics}\n</code></pre>"},{"location":"endpoints/lyrics/#routes.lyrics.get_random_row_and_lyrics_and_metadata","title":"<code>get_random_row_and_lyrics_and_metadata(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Fetches a random song from the music library along with its lyrics and metadata including artwork.</p> <ul> <li>user: User - The authenticated user making the request.</li> <li>db: Session - The database session for querying the database.</li> <li>return: Returns a JSON object containing the song's ID, details, lyrics from the lyrics.ovh API, and artwork from the metadata.</li> </ul> Source code in <code>routes/lyrics.py</code> <pre><code>@router.get(\"/random-lyrics-metadata\", tags=[\"lyrics\"])\ndef get_random_row_and_lyrics_and_metadata(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Fetches a random song from the music library along with its lyrics and metadata including artwork.\n\n    - **user**: User - The authenticated user making the request.\n    - **db**: Session - The database session for querying the database.\n    - **return**: Returns a JSON object containing the song's ID, details, lyrics from the lyrics.ovh API, and artwork from the metadata.\n    \"\"\"\n    with db:\n        row = db.query(MusicLibrary).order_by(func.random()).first()\n        if row is None:\n            raise HTTPException(status_code=404, detail=\"No songs found in the library.\")\n        lyrics = fetch_lyrics(row.artist, row.title)\n        artwork = get_artwork(\"megasetbucket\", row.filepath)\n        return {\"id\": row.id, \"row\": row, \"lyrics\": lyrics, \"artwork\": artwork}\n</code></pre>"},{"location":"endpoints/milvus/","title":"Documentation for <code>routes/milvus.py</code>","text":"<p>This module contains the endpoints for the Milvus service. It provides routes for performing queries such as similarity searches on the Milvus vector database.</p>"},{"location":"endpoints/milvus/#routes.milvus.get_entity_by_id","title":"<code>get_entity_by_id(id, user=Depends(login_manager))</code>","text":"<p>Retrieves the embedding vector of a specific entity by its ID.</p> <ul> <li>id: str - The unique identifier of the entity.</li> <li>user: User - The authenticated user making the request.</li> <li>return: EmbeddingResponse - The embedding vector of the entity.</li> </ul> Source code in <code>routes/milvus.py</code> <pre><code>@router.get(\"/entity/{id}\", response_model=EmbeddingResponse, tags=[\"milvus\"])\ndef get_entity_by_id(id: str, user=Depends(login_manager)):\n    \"\"\"\n    Retrieves the embedding vector of a specific entity by its ID.\n\n    - **id**: str - The unique identifier of the entity.\n    - **user**: User - The authenticated user making the request.\n    - **return**: EmbeddingResponse - The embedding vector of the entity.\n    \"\"\"\n    collection_512 = get_milvus_512_collection()\n    entities = collection_512.query(expr=f\"id in [{id}]\", output_fields=[\"embedding\"])\n    if not entities:\n        raise HTTPException(status_code=404, detail=\"Entity not found\")\n\n    embedding = [float(x) for x in entities[0][\"embedding\"]]\n    return EmbeddingResponse(id=id, embedding=embedding)\n</code></pre>"},{"location":"endpoints/milvus/#routes.milvus.get_genres_plot","title":"<code>get_genres_plot(query, user=Depends(login_manager))</code>  <code>async</code>","text":"<p>Generates a plot of the top 5 genres for a given entity based on its file path.</p> <ul> <li>query: SongPath - The query containing the file path of the entity.</li> <li>user: User - The authenticated user making the request.</li> <li>return: A base64 encoded string of the plot image.</li> </ul> Source code in <code>routes/milvus.py</code> <pre><code>@router.post(\"/plot_genres\", tags=[\"milvus\"])\nasync def get_genres_plot(query: SongPath, user=Depends(login_manager)):\n    \"\"\"\n    Generates a plot of the top 5 genres for a given entity based on its file path.\n\n    - **query**: SongPath - The query containing the file path of the entity.\n    - **user**: User - The authenticated user making the request.\n    - **return**: A base64 encoded string of the plot image.\n    \"\"\"\n    collection_87 = get_milvus_87_collection()\n    entity = collection_87.query(\n        expr=f\"path == '{query.file_path}'\",\n        output_fields=[\"predictions\", \"title\", \"artist\"], \n        limit=1\n    )\n    if not entity:\n        raise HTTPException(status_code=404, detail=\"Entity not found\")\n\n    class_names, top_5_activations, title, artist = await extract_plot_data(entity)\n    fig = await create_plot(class_names, top_5_activations, title, artist)\n    image_base64 = await convert_plot_to_base64(fig)\n\n    return Response(content=image_base64, media_type=\"text/plain\")\n</code></pre>"},{"location":"endpoints/milvus/#routes.milvus.get_similar_9_entities_by_path","title":"<code>get_similar_9_entities_by_path(query, user=Depends(login_manager))</code>","text":"<p>Retrieves the 9 most similar entities (by title, artist, album) based on the file path of an entity.</p> <ul> <li>query: FilePathsQuery - The query containing the file path(s) of the entity.</li> <li>user: User - The authenticated user making the request.</li> <li>return: A list of the 9 most similar entities with short details.</li> </ul> Source code in <code>routes/milvus.py</code> <pre><code>@router.post(\"/similar_short_entity\", tags=[\"milvus\"], response_model=SimilarShortEntitiesResponse)\ndef get_similar_9_entities_by_path(query: FilePathsQuery, user=Depends(login_manager)):\n    \"\"\"\n    Retrieves the 9 most similar entities (by title, artist, album) based on the file path of an entity.\n\n    - **query**: FilePathsQuery - The query containing the file path(s) of the entity.\n    - **user**: User - The authenticated user making the request.\n    - **return**: A list of the 9 most similar entities with short details.\n    \"\"\"\n    collection_512 = get_milvus_512_collection()\n    entities = collection_512.query(expr=f\"path in {query.path}\", output_fields=[\"embedding\"])\n    if not entities:\n        raise HTTPException(status_code=404, detail=\"Entity not found\")\n\n    embeddings = [[float(x) for x in entity[\"embedding\"]] for entity in entities]\n    entities = collection_512.search(\n        data=embeddings,\n        anns_field=\"embedding\",\n        param={\"nprobe\": 16},\n        limit=30,\n        offset=1,\n        output_fields=[\"title\", \"album\", \"artist\", \"path\"],\n    )\n\n    sorted_entities = sort_entities(entities)\n    return {\"entities\": sorted_entities}\n</code></pre>"},{"location":"endpoints/milvus/#routes.milvus.get_similar_entities","title":"<code>get_similar_entities(id, user=Depends(login_manager))</code>","text":"<p>Retrieves the top 3 most similar entities to a given entity ID.</p> <ul> <li>id: str - The unique identifier of the entity to compare.</li> <li>user: User - The authenticated user making the request.</li> <li>return: SimilarFullEntitiesResponse - A list of the most similar entities.</li> </ul> Source code in <code>routes/milvus.py</code> <pre><code>@router.get(\"/similar/{id}\", tags=[\"milvus\"], response_model=SimilarFullEntitiesResponse)\ndef get_similar_entities(id: str, user=Depends(login_manager)):\n    \"\"\"\n    Retrieves the top 3 most similar entities to a given entity ID.\n\n    - **id**: str - The unique identifier of the entity to compare.\n    - **user**: User - The authenticated user making the request.\n    - **return**: SimilarFullEntitiesResponse - A list of the most similar entities.\n    \"\"\"\n    collection_512 = get_milvus_512_collection()\n    entities = collection_512.query(expr=f\"id in [{id}]\", output_fields=[\"embedding\"])\n    if not entities:\n        raise HTTPException(status_code=404, detail=\"Entity not found\")\n\n    embedding = [float(x) for x in entities[0][\"embedding\"]]\n    entities = collection_512.search(\n        data=[embedding],\n        anns_field=\"embedding\",\n        param={\"nprobe\": 16},\n        limit=3,\n        offset=1,\n        output_fields=[\"*\"],\n    )\n\n    response_list = [full_hit_to_dict(hit) for hit in entities[0]]\n    return SimilarFullEntitiesResponse(hits=response_list)\n</code></pre>"},{"location":"endpoints/milvus/#routes.milvus.get_similar_entities_by_path","title":"<code>get_similar_entities_by_path(query, user=Depends(login_manager))</code>","text":"<p>Retrieves the top 3 most similar entities based on the file path of an entity.</p> <ul> <li>query: FilePathsQuery - The query containing the file path(s) of the entity.</li> <li>user: User - The authenticated user making the request.</li> <li>return: SimilarFullEntitiesResponse - A list of the most similar entities with full details.</li> </ul> Source code in <code>routes/milvus.py</code> <pre><code>@router.post(\"/similar_full_entity\", tags=[\"milvus\"], response_model=SimilarFullEntitiesResponse)\ndef get_similar_entities_by_path(query: FilePathsQuery, user=Depends(login_manager)):\n    \"\"\"\n    Retrieves the top 3 most similar entities based on the file path of an entity.\n\n    - **query**: FilePathsQuery - The query containing the file path(s) of the entity.\n    - **user**: User - The authenticated user making the request.\n    - **return**: SimilarFullEntitiesResponse - A list of the most similar entities with full details.\n    \"\"\"\n    collection_512 = get_milvus_512_collection()\n    entities = collection_512.query(expr=f\"path in {query.path}\", output_fields=[\"embedding\"])\n    if not entities:\n        raise HTTPException(status_code=404, detail=\"Entity not found\")\n\n    embeddings = [[float(x) for x in entity[\"embedding\"]] for entity in entities]\n    entities = collection_512.search(\n        data=embeddings,\n        anns_field=\"embedding\",\n        param={\"nprobe\": 16},\n        limit=3,\n        offset=1,\n        output_fields=[\"*\"],\n    )\n\n    response_list = [short_hit_to_dict(hit) for hit in entities[0]]\n    return SimilarFullEntitiesResponse(hits=response_list)\n</code></pre>"},{"location":"endpoints/milvus/#routes.milvus.ping_milvus_collection","title":"<code>ping_milvus_collection()</code>","text":"<p>Checks the connectivity with the Milvus vector database. Mostly used to make prometheus ping milvus everyday, so milvus doesn't get idle for 7 days and shutdown.</p> <ul> <li>return: The status of the Milvus service.</li> </ul> Source code in <code>routes/milvus.py</code> <pre><code>@router.get(\"/ping\", tags=[\"milvus\"])\ndef ping_milvus_collection():\n    \"\"\"\n    Checks the connectivity with the Milvus vector database. Mostly used to make prometheus ping milvus everyday, so milvus doesn't get idle for 7 days and shutdown.\n\n    - **return**: The status of the Milvus service.\n    \"\"\"\n    milvus_status = ping_milvus()\n    return milvus_status\n</code></pre>"},{"location":"endpoints/minio/","title":"Documentation for <code>routes/minio.py</code>","text":"<p>This module contains the endpoints for the MiniO service.  It provides endpoints for storing and retriveing objects from MiniO buckets.</p>"},{"location":"endpoints/minio/#routes.minio.download_file","title":"<code>download_file(query, user=Depends(login_manager))</code>  <code>async</code>","text":"<p>Downloads a song file from MinIO storage.</p> <ul> <li>query: SongPath - The path to the song file in MinIO storage.</li> <li>user: User - The authenticated user making the request.</li> <li>return: StreamingResponse - A streaming response for downloading the song file.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.post(\"/download-song/\", tags=[\"MinIO\"])\nasync def download_file(query: SongPath, user=Depends(login_manager)):\n    \"\"\"\n    Downloads a song file from MinIO storage.\n\n    - **query**: SongPath - The path to the song file in MinIO storage.\n    - **user**: User - The authenticated user making the request.\n    - **return**: StreamingResponse - A streaming response for downloading the song file.\n    \"\"\"\n    try:\n        data = minio_client.get_object(DEFAULT_SETTINGS.minio_bucket_name, query.file_path)\n        filename = query.file_path.split('/')[-1]  # Get the filename from the file_path\n        headers = {\n            \"Content-Disposition\": f\"attachment; filename={filename}\",\n        }\n        return StreamingResponse(data.stream(32*1024), media_type=\"audio/mpeg\", headers=headers)\n    except Exception as e:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n</code></pre>"},{"location":"endpoints/minio/#routes.minio.get_file","title":"<code>get_file(query, user=Depends(login_manager))</code>  <code>async</code>","text":"<p>Streams a song file from MinIO storage.</p> <ul> <li>query: SongPath - The path to the song file in MinIO storage.</li> <li>user: User - The authenticated user making the request.</li> <li>return: StreamingResponse - A streaming response of the song file.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.post(\"/stream-song/\", tags=[\"MinIO\"])\nasync def get_file(query: SongPath, user=Depends(login_manager)):\n    \"\"\"\n    Streams a song file from MinIO storage.\n\n    - **query**: SongPath - The path to the song file in MinIO storage.\n    - **user**: User - The authenticated user making the request.\n    - **return**: StreamingResponse - A streaming response of the song file.\n    \"\"\"\n    try:\n        data = minio_client.get_object(DEFAULT_SETTINGS.minio_bucket_name, query.file_path)\n        return StreamingResponse(data.stream(32*1024), media_type=\"audio/mpeg\")\n    except Exception as e:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n</code></pre>"},{"location":"endpoints/minio/#routes.minio.get_random_song_metadata","title":"<code>get_random_song_metadata(user=Depends(login_manager), db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieves metadata for a random song from MinIO storage using the music-tag library.</p> <ul> <li>user: User - The authenticated user making the request.</li> <li>db: Session - Database session dependency.</li> <li>return: JSONResponse - The metadata of a random song.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.get(\"/random-metadata\", tags=[\"MinIO\"])\nasync def get_random_song_metadata(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieves metadata for a random song from MinIO storage using the music-tag library.\n\n    - **user**: User - The authenticated user making the request.\n    - **db**: Session - Database session dependency.\n    - **return**: JSONResponse - The metadata of a random song.\n    \"\"\"\n    try:\n        count = db.query(MusicLibrary).count()\n        random_id = randint(1, count)\n        row = db.query(MusicLibrary).filter(MusicLibrary.id == random_id).first()\n        metadata = get_metadata_and_artwork(DEFAULT_SETTINGS.minio_bucket_name, row.filepath)\n        return JSONResponse(content=metadata)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/minio/#routes.minio.get_song_metadata","title":"<code>get_song_metadata(query, user=Depends(login_manager))</code>  <code>async</code>","text":"<p>Retrieves metadata for a specified song from MinIO storage using the music-tag library.</p> <ul> <li>query: SongPath - The path to the song file in MinIO storage.</li> <li>user: User - The authenticated user making the request.</li> <li>return: JSONResponse - The metadata of the specified song.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.post(\"/metadata\", tags=[\"MinIO\"])\nasync def get_song_metadata(query: SongPath, user=Depends(login_manager)):\n    \"\"\"\n    Retrieves metadata for a specified song from MinIO storage using the music-tag library.\n\n    - **query**: SongPath - The path to the song file in MinIO storage.\n    - **user**: User - The authenticated user making the request.\n    - **return**: JSONResponse - The metadata of the specified song.\n    \"\"\"\n    try:\n        metadata = get_metadata_and_artwork(DEFAULT_SETTINGS.minio_bucket_name, query.file_path)\n        return JSONResponse(content=metadata)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n</code></pre>"},{"location":"endpoints/minio/#routes.minio.list_objects_in_album_folder","title":"<code>list_objects_in_album_folder(query, user=Depends(login_manager))</code>","text":"<p>Retrieves a list of objects within a specified album folder in the MinIO bucket.</p> <ul> <li>query: AlbumResponse - The album folder to list objects from.</li> <li>user: User - The authenticated user making the request.</li> <li>return: List[S3Object] - A list of objects found in the specified album folder.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.post(\"/list-objects/\", response_model=List[S3Object], tags=[\"MinIO\"])\ndef list_objects_in_album_folder(query: AlbumResponse, user=Depends(login_manager)):\n    \"\"\"\n    Retrieves a list of objects within a specified album folder in the MinIO bucket.\n\n    - **query**: AlbumResponse - The album folder to list objects from.\n    - **user**: User - The authenticated user making the request.\n    - **return**: List[S3Object] - A list of objects found in the specified album folder.\n    \"\"\"\n    objects = minio_client.list_objects(\n        DEFAULT_SETTINGS.minio_bucket_name,\n        prefix=query.album_folder,\n        recursive=True)\n\n    response = []\n    for obj in objects:\n        s3_object = {\n            \"name\": obj.object_name,\n            \"size\": obj.size,\n            \"etag\": obj.etag,\n            \"last_modified\": obj.last_modified.isoformat()\n        }\n        response.append(s3_object)\n\n    return response\n</code></pre>"},{"location":"endpoints/minio/#routes.minio.list_uploaded_objects","title":"<code>list_uploaded_objects(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Lists objects uploaded by the authenticated user.</p> <ul> <li>user: User - The authenticated user making the request.</li> <li>db: Session - Database session dependency.</li> <li>return: UploadMP3ResponseList - A list of uploaded objects by the user.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.post(\"/list-uploaded-objects\", response_model=UploadMP3ResponseList, tags=[\"MinIO\"])\ndef list_uploaded_objects(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Lists objects uploaded by the authenticated user.\n\n    - **user**: User - The authenticated user making the request.\n    - **db**: Session - Database session dependency.\n    - **return**: UploadMP3ResponseList - A list of uploaded objects by the user.\n    \"\"\"\n    objects = minio_client.list_objects(DEFAULT_SETTINGS.minio_temp_bucket_name)\n    # Adjusting the response to match the expected structure\n    uploads = [UploadDetail(filename=obj.object_name) for obj in objects]\n    response = UploadMP3ResponseList(uploads=uploads)\n    return response\n</code></pre>"},{"location":"endpoints/minio/#routes.minio.upload_file","title":"<code>upload_file(file=File(...), user=Depends(login_manager), db=Depends(get_db))</code>  <code>async</code>","text":"<p>Uploads a MP3 file to MinIO storage using a temporary bucket.</p> <ul> <li>file: UploadFile - The MP3 file to upload.</li> <li>user: User - The authenticated user making the request.</li> <li>db: Session - Database session dependency.</li> <li>return: UploadMP3ResponseList - A list of uploaded MP3 files by the user.</li> </ul> Source code in <code>routes/minio.py</code> <pre><code>@router.post(\"/upload-temp\", tags=[\"MinIO\"], response_model=UploadMP3ResponseList)\nasync def upload_file(file: UploadFile = File(...), user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Uploads a MP3 file to MinIO storage using a temporary bucket.\n\n    - **file**: UploadFile - The MP3 file to upload.\n    - **user**: User - The authenticated user making the request.\n    - **db**: Session - Database session dependency.\n    - **return**: UploadMP3ResponseList - A list of uploaded MP3 files by the user.\n    \"\"\"\n    try:   # Check content type and extension\n        if file.content_type != \"audio/mpeg\":\n            raise HTTPException(status_code=400, detail=\"Only MP3 files are allowed.\")\n        _, file_extension = os.path.splitext(file.filename)\n        if file_extension.lower() != \".mp3\":\n            raise HTTPException(status_code=400, detail=\"The uploaded file is not an MP3 file.\")\n\n        # Generate a secure filename\n        secure_filename = sanitize_filename(file.filename)\n\n        # Determine the size of the uploaded file by moving the cursor to the end to get the file size\n        file.file.seek(0, os.SEEK_END)  \n        file_size = file.file.tell() \n        file.file.seek(0)  \n\n        # Stream the file directly to MinIO\n        minio_client.put_object(\n            bucket_name=DEFAULT_SETTINGS.minio_temp_bucket_name,\n            object_name=secure_filename,\n            data=file.file,\n            length=file_size,\n            content_type=file.content_type\n        )\n\n        # Store upload information in the database and return the updated list of uploaded songs by the user\n        # song_path_in_minio = f\"{DEFAULT_SETTINGS.minio_temp_bucket_name}/{secure_filename}\"\n        store_upload_info(db, user.id, secure_filename)\n        uploaded_songs = get_user_uploads(db, user.id)\n\n        return UploadMP3ResponseList(uploads=uploaded_songs)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"An unexpected error occurred. {str(e)}\")\n</code></pre>"},{"location":"endpoints/monitoring/","title":"Documentation for <code>routes/monitoring.py</code>","text":"<p>This module contains endpoint to retrives various system statistics on a Linux machine, including CPU temperature, CPU usage, memory usage, and disk usage.</p>"},{"location":"endpoints/monitoring/#routes.monitoring.get_all_pi","title":"<code>get_all_pi(user=Depends(login_manager))</code>  <code>async</code>","text":"<p>Retrieves comprehensive monitoring statistics for a Linux host machine.</p> <p>These statistics include CPU usage, memory usage, disk space, temperature readings.</p> <ul> <li>user: User - The authenticated user making the request, verified through the <code>login_manager</code>.</li> <li>return: A JSON response containing the linux host's monitoring statistics.</li> </ul> Source code in <code>routes/monitoring.py</code> <pre><code>@router.get(\"/pi\", tags=[\"monitoring\"])\nasync def get_all_pi(user=Depends(login_manager)):\n    \"\"\"\n    Retrieves comprehensive monitoring statistics for a Linux host machine.\n\n    These statistics include CPU usage, memory usage, disk space, temperature readings.\n\n    - **user**: User - The authenticated user making the request, verified through the `login_manager`.\n    - **return**: A JSON response containing the linux host's monitoring statistics.\n    \"\"\"\n    return get_all_pi_stats()\n</code></pre>"},{"location":"endpoints/music/","title":"Documentation for <code>routes/music.py</code>","text":"<p>This module contains the endpoints for operations on the music database. It provides routes for searching for music by song title and artist.</p>"},{"location":"endpoints/music/#routes.music.add_row","title":"<code>add_row(query, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Adds a new song to the music_library table.</p> <ul> <li>Parameters:<ul> <li>query: AddSongToMusicLibrary object containing the song details to be added.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A message indicating successful addition of the song.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.post(\"/add\", tags=[\"songs\"])\ndef add_row(query: AddSongToMusicLibrary, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Adds a new song to the music_library table.\n\n    - **Parameters**:\n        - **query**: AddSongToMusicLibrary object containing the song details to be added.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A message indicating successful addition of the song.\n    \"\"\"\n    try:\n        max_id = db.query(func.max(MusicLibrary.id)).scalar()  # Get the maximum id from the music_library table\n        if max_id is None: max_id = 0  # If the table is empty, set max_id to 0\n\n        # insert into the table\n        stmt = insert(MusicLibrary).values(\n            id=max_id + 1,  # Set the id to one more than the current maximum\n            filename=query.filename, filepath=query.filepath, album_folder=query.album_folder,\n            artist_folder=query.artist_folder, filesize=query.filesize, title=query.title,\n            artist=query.artist, album=query.album, year=query.year, tracknumber=query.tracknumber,\n            genre=query.genre, top_5_genres=query.top_5_genres,\n        )\n        db.execute(stmt)\n        db.commit()\n        return {\"message\": \"Row added successfully\"}\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.count_rows","title":"<code>count_rows(db=Depends(get_db))</code>","text":"<p>Returns the total number of rows in the music_library table.</p> <ul> <li>Parameters: None</li> <li>Returns: An integer representing the total number of rows in the music_library table.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.get(\"/count\", tags=[\"songs\"])\ndef count_rows(db: Session = Depends(get_db)):\n    \"\"\"\n    Returns the total number of rows in the music_library table.\n\n    - **Parameters**: None\n    - **Returns**: An integer representing the total number of rows in the music_library table.\n    \"\"\"\n    try:\n        result = db.execute(text(\"SELECT COUNT(*) FROM music_library\"))\n        count = result.scalar()\n        return count\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.delete_row","title":"<code>delete_row(id, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Deletes a specific song from the music_library table by its ID.</p> <ul> <li>Parameters:<ul> <li>id: Integer, the ID of the song to delete.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A message indicating successful deletion of the song. Raises a 404 HTTPException if the song is not found.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.delete(\"/delete/{id}\", tags=[\"songs\"])\ndef delete_row(id: int, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Deletes a specific song from the music_library table by its ID.\n\n    - **Parameters**:\n        - **id**: Integer, the ID of the song to delete.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A message indicating successful deletion of the song. Raises a 404 HTTPException if the song is not found.\n    \"\"\"\n    try:\n        row = db.query(MusicLibrary).get(id)\n        if row is None:\n            raise HTTPException(status_code=404, detail=\"Row not found\")\n        db.delete(row)\n        db.commit()\n        return {\"message\": \"Row deleted successfully\"}\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.get_album_folder_by_artist_and_album","title":"<code>get_album_folder_by_artist_and_album(query, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Retrieves the album folder for a specific artist and album combination in the music_library table.</p> <ul> <li>Parameters:<ul> <li>query: ArtistAlbumResponse object containing the artist's name and album title.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A dictionary containing the album folder name. Raises a 404 HTTPException if the album is not found.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.post(\"/album_folder_by_artist_and_album\", tags=[\"songs\"])\ndef get_album_folder_by_artist_and_album(\n    query: ArtistAlbumResponse, user=Depends(login_manager), db: Session = Depends(get_db)\n):\n    \"\"\"\n    Retrieves the album folder for a specific artist and album combination in the music_library table.\n\n    - **Parameters**:\n        - **query**: ArtistAlbumResponse object containing the artist's name and album title.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A dictionary containing the album folder name. Raises a 404 HTTPException if the album is not found.\n    \"\"\"\n    artist = query.artist\n    album = query.album\n    try:\n        row = db.query(MusicLibrary.album_folder).filter(MusicLibrary.artist == artist, MusicLibrary.album == album).first()\n        if row is None:\n            raise HTTPException(status_code=404, detail=\"Album not found\")\n        return {\"album_folder\": row.album_folder}\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.get_random_row","title":"<code>get_random_row(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Retrieves a random song from the music_library table.</p> <ul> <li>Parameters:<ul> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A dictionary containing the ID of the randomly selected song and the song's row data.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.get(\"/random\", tags=[\"songs\"])\ndef get_random_row(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieves a random song from the music_library table.\n\n    - **Parameters**:\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A dictionary containing the ID of the randomly selected song and the song's row data.\n    \"\"\"\n    try:\n        count = db.query(MusicLibrary).count()\n        random_id = randint(1, count)\n        row = db.query(MusicLibrary).filter(MusicLibrary.id == random_id).first()\n        return {\"id\": random_id, \"row\": row}\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.get_song_by_id","title":"<code>get_song_by_id(id, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Fetches a specific song from the music_library table by its ID.</p> <ul> <li>Parameters:<ul> <li>id: Integer, the ID of the song to retrieve.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A dictionary containing the ID of the song and the song's row data. Raises a 404 HTTPException if the song is not found.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.get(\"/song/{id}\", tags=[\"songs\"])\ndef get_song_by_id(id: int, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Fetches a specific song from the music_library table by its ID.\n\n    - **Parameters**:\n        - **id**: Integer, the ID of the song to retrieve.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A dictionary containing the ID of the song and the song's row data. Raises a 404 HTTPException if the song is not found.\n    \"\"\"\n    try:\n        row = db.query(MusicLibrary).filter(MusicLibrary.id == id).first()\n        if row is None:\n            raise HTTPException(status_code=404, detail=\"Song not found\")\n        return {\"id\": id, \"row\": row}\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.list_all_albums","title":"<code>list_all_albums(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Lists all albums in the music_library table, ordered by release date.</p> <ul> <li>Parameters: None</li> <li>Returns: A list of dictionaries, each containing the album name, album folder, and release year, ordered by release year.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.get(\"/albums\", tags=[\"songs\"])\ndef list_all_albums(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Lists all albums in the music_library table, ordered by release date.\n\n    - **Parameters**: None\n    - **Returns**: A list of dictionaries, each containing the album name, album folder, and release year, ordered by release year.\n    \"\"\"\n    try:\n        query = (\n            db.query(MusicLibrary.album, MusicLibrary.album_folder, MusicLibrary.year)\n            .distinct()\n            .order_by(MusicLibrary.year.asc())\n        )\n        return [{\"album\": row.album, \"album_folder\": row.album_folder} for row in query.all()]\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.list_all_albums_from_artist","title":"<code>list_all_albums_from_artist(artist_folder, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Lists all albums by a specific artist in the music_library table, ordered by release date.</p> <ul> <li>Parameters:<ul> <li>artist_folder: ArtistFolderResponse object containing the artist's folder name.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A list of album names for the given artist, ordered by release date.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.post(\"/albums\", tags=[\"songs\"])\ndef list_all_albums_from_artist(artist_folder: ArtistFolderResponse, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Lists all albums by a specific artist in the music_library table, ordered by release date.\n\n    - **Parameters**:\n        - **artist_folder**: ArtistFolderResponse object containing the artist's folder name.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A list of album names for the given artist, ordered by release date.\n    \"\"\"\n    if artist_folder is None or artist_folder.artist_folder is None:\n        raise HTTPException(status_code=400, detail=\"Missing artist_folder parameter\")\n    try:\n        query = (\n            db.query(MusicLibrary.album)\n            .filter(MusicLibrary.artist_folder == artist_folder.artist_folder)\n            .distinct()\n        )\n        return [row.album for row in query.all()]\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.list_all_artists","title":"<code>list_all_artists(user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Lists all artists in the music_library table in alphabetical order.</p> <ul> <li>Parameters: None</li> <li>Returns: A list of artist names in alphabetical order.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.get(\"/artists\", tags=[\"songs\"])\ndef list_all_artists(user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Lists all artists in the music_library table in alphabetical order.\n\n    - **Parameters**: None\n    - **Returns**: A list of artist names in alphabetical order.\n    \"\"\"\n    try:\n        query = (db.query(MusicLibrary.artist_folder).distinct().order_by(MusicLibrary.artist_folder.asc()))\n        return [row.artist_folder for row in query.all()]\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.list_all_songs_from_album","title":"<code>list_all_songs_from_album(album_folder=None, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Lists all songs from a specific album in the music_library table.</p> <ul> <li>Parameters:<ul> <li>album_folder: AlbumResponse object containing the album's folder name.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A list of dictionaries, each containing the track number and title of a song from the specified album.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.post(\"/songs\", tags=[\"songs\"])\ndef list_all_songs_from_album(album_folder: AlbumResponse = None, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Lists all songs from a specific album in the music_library table.\n\n    - **Parameters**:\n        - **album_folder**: AlbumResponse object containing the album's folder name.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A list of dictionaries, each containing the track number and title of a song from the specified album.\n    \"\"\"\n    if album_folder is None or album_folder.album_folder is None:\n        raise HTTPException(status_code=400, detail=\"Missing album_folder parameter\")\n    try:\n        query = db.query(MusicLibrary).filter(MusicLibrary.album_folder == album_folder.album_folder)\n        return [\n            {\"tracknumber\": row.tracknumber, \"title\": row.title}\n            for row in query.order_by(MusicLibrary.tracknumber.asc()).all()\n        ]\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/music/#routes.music.list_all_songs_from_artist_and_album","title":"<code>list_all_songs_from_artist_and_album(query, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Lists all songs by a specific artist and from a specific album in the music_library table.</p> <ul> <li>Parameters:<ul> <li>query: ArtistAlbumResponse object containing the artist's name and album title.</li> <li>user: User object, automatically provided by the login_manager dependency.</li> </ul> </li> <li>Returns: A list of dictionaries, each containing the track number, file path, and title of a song from the specified artist and album.</li> </ul> Source code in <code>routes/music.py</code> <pre><code>@router.post(\"/songs/by_artist_and_album\", tags=[\"songs\"])\ndef list_all_songs_from_artist_and_album(\n    query: ArtistAlbumResponse, user=Depends(login_manager), db: Session = Depends(get_db)\n):\n    \"\"\"\n    Lists all songs by a specific artist and from a specific album in the music_library table.\n\n    - **Parameters**:\n        - **query**: ArtistAlbumResponse object containing the artist's name and album title.\n        - **user**: User object, automatically provided by the login_manager dependency.\n    - **Returns**: A list of dictionaries, each containing the track number, file path, and title of a song from the specified artist and album.\n    \"\"\"\n    artist = query.artist\n    album = query.album\n    try:\n        query = db.query(MusicLibrary).filter(MusicLibrary.artist == artist, MusicLibrary.album == album)\n        return [\n            {\"tracknumber\": row.tracknumber, \"path\": row.filepath, \"title\": row.title}\n            for row in query.order_by(MusicLibrary.tracknumber.asc()).all()\n        ]\n    finally:\n        db.close()\n</code></pre>"},{"location":"endpoints/openl3/","title":"Documentation for <code>routes/openl3.py</code>","text":"<p>This module contains the endpoints for the OpenL3 service. It provides routes for extracting audio embeddings using the OpenL3 model. The embeddings can then be used to perform similarity searches on the embeddings using the Milvus service.</p>"},{"location":"endpoints/openl3/#routes.openl3.get_embeddings","title":"<code>get_embeddings(file_path, user=Depends(login_manager), db=Depends(get_db))</code>","text":"<p>Retrieves the embeddings for a specified audio file.</p> <p>This function loads a model from MinIO, retrieves the specified audio file as a temporary file, computes the embeddings using the loaded model, and then cleans up the temporary file. If successful, it returns an EmbeddingResponse object containing the file name and its embeddings. If the process fails, it raises an HTTPException with status code 500.</p> <p>Parameters: - file_path (str): The path to the audio file for which embeddings are to be computed. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency.</p> <p>Returns: - EmbeddingResponse: An object containing the file name and its computed embeddings.</p> Source code in <code>routes/openl3.py</code> <pre><code>@router.post(\"/embeddings/\", response_model=EmbeddingResponse, tags=[\"OpenL3\"])\ndef get_embeddings(file_path: str, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieves the embeddings for a specified audio file.\n\n    This function loads a model from MinIO, retrieves the specified audio file as a temporary file,\n    computes the embeddings using the loaded model, and then cleans up the temporary file. If successful,\n    it returns an EmbeddingResponse object containing the file name and its embeddings. If the process fails,\n    it raises an HTTPException with status code 500.\n\n    Parameters:\n    - file_path (str): The path to the audio file for which embeddings are to be computed.\n    - user: The current user object, automatically provided by the login_manager dependency.\n    - db: The database session, automatically provided by the get_db dependency.\n\n    Returns:\n    - EmbeddingResponse: An object containing the file name and its computed embeddings.\n\n    \"\"\"\n    print(f\"Starting to get embeddings for file: {file_path}\")\n    try:\n        embedding_512_model = load_model_from_minio()\n        temp_file_path = get_temp_file_from_minio(file_path)\n\n        # Compute embeddings using the temporary file path\n        vector = embedding_512_model.compute(temp_file_path)\n        embedding = vector.mean(axis=0)\n\n        # Clean up the temporary file\n        os.unlink(temp_file_path)\n\n        print(f\"Successfully processed embeddings for file: {file_path}\")\n        return EmbeddingResponse(file_name=file_path, embedding=embedding.tolist())\n    except Exception as e:\n        print(f\"Failed to get embeddings for file: {file_path}. Error: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Failed to process the request: {e}\")\n</code></pre>"},{"location":"endpoints/spotinite/","title":"Documentation for <code>routes/spotinite.py</code>","text":"<p>This module contains the endpoints for what we call, the 'Spotinite service'. It provides routes for using the python spotipy library to interact with the Cyanite API. The Cyanite API is a music recommendation service. It uses the Spotify's ID to identify songs and can recommend songs based on a given artist or band name and a track title.</p>"},{"location":"endpoints/spotinite/#routes.spotinite.similar_tracks","title":"<code>similar_tracks(query, user=Depends(login_manager), db=Depends(get_db))</code>  <code>async</code>","text":"<p>Fetches and returns a list of tracks similar to the specified song and artist.</p> <p>This endpoint takes a song title and artist as input, retrieves a Spotify ID for the song, and then fetches a list of similar tracks based on that ID. It aims to return 3 similar tracks that are not by the same artist as the input song, if possible. If not enough non-artist matches are found, it will include tracks by the same artist in the response.</p> <p>Parameters: - query (SpotiniteQuery): The query object containing the title and artist of the song. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency.</p> <p>Returns: - List[SpotiniteResponse]: A list of similar tracks, each represented by a SpotiniteResponse object.</p> Source code in <code>routes/spotinite.py</code> <pre><code>@router.post(\"/similar_tracks\", response_model=List[SpotiniteResponse], tags=[\"spotinite\"])\nasync def similar_tracks(query: SpotiniteQuery, user=Depends(login_manager), db: Session = Depends(get_db)):\n    \"\"\"\n    Fetches and returns a list of tracks similar to the specified song and artist.\n\n    This endpoint takes a song title and artist as input, retrieves a Spotify ID for the song,\n    and then fetches a list of similar tracks based on that ID. It aims to return 3 similar tracks\n    that are not by the same artist as the input song, if possible. If not enough non-artist matches\n    are found, it will include tracks by the same artist in the response.\n\n    Parameters:\n    - query (SpotiniteQuery): The query object containing the title and artist of the song.\n    - user: The current user object, automatically provided by the login_manager dependency.\n    - db: The database session, automatically provided by the get_db dependency.\n\n    Returns:\n    - List[SpotiniteResponse]: A list of similar tracks, each represented by a SpotiniteResponse object.\n\n    \"\"\"\n    try:\n        spotify_id = get_track_id(query.title, query.artist)\n        similar_track_ids = fetch_similar_tracks(spotify_id)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n    # Fetch 15 similar tracks and return the first 3 that are not by the same artist if possible\n    similar_tracks = []\n    added_artists = set()\n    backup_tracks = []\n    for track_id in similar_track_ids:\n        track_info = get_track_info(track_id)\n        artist_lower = track_info['Artist'].lower()\n        if artist_lower != query.artist.lower() and artist_lower not in added_artists:\n            similar_tracks.append(track_info)\n            added_artists.add(artist_lower)\n        else:\n            backup_tracks.append(track_info)\n        if len(similar_tracks) == 3:\n            break\n\n    if len(similar_tracks) &lt; 3:\n        similar_tracks.extend(backup_tracks[:3-len(similar_tracks)])\n\n    return similar_tracks\n</code></pre>"},{"location":"endpoints/uploaded/","title":"Documentation for <code>routes/uploaded.py</code>","text":"<p>This module provides endpoints to interact with a MiniO bucket for storing and retrieving user uploaded songs.</p>"},{"location":"services/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"services/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> <li><code>mkdocs gh-deploy</code> - Deploy the documentation to GitHub Pages.</li> </ul>"},{"location":"services/#project-layout","title":"Project layout","text":"<pre><code>.\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 docker-compose.yaml\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 core\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 database.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2514\u2500\u2500 data\n\u2502       \u2514\u2500\u2500 music.db\n\u2502\n\u251c\u2500\u2500 gui\n\u2502   \u2514\u2500\u2500 templates\n\u2502       \u2514\u2500\u2500 index.html\n\u2502\n\u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 milvus.py\n\u2502   \u251c\u2500\u2500 minio.py\n\u2502   \u251c\u2500\u2500 music.py\n\u2502   \u251c\u2500\u2500 spotinite.py\n\u2502   \u2514\u2500\u2500 users.py\n\u2502\n\u251c\u2500\u2500 routes\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u251c\u2500\u2500 lyrics.py\n\u2502   \u251c\u2500\u2500 milvus.py\n\u2502   \u251c\u2500\u2500 music.py\n\u2502   \u2514\u2500\u2500 spotinite.py\n\u2502\n\u251c\u2500\u2500 services\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u251c\u2500\u2500 lyrics.py\n\u2502   \u251c\u2500\u2500 milvus.py\n\u2502   \u251c\u2500\u2500 minio.py\n\u2502   \u2514\u2500\u2500 spotinite.py\n\u2502\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_files.py\n</code></pre>"},{"location":"services/auth/","title":"Documentation for <code>services/auth.py</code>","text":"<p>This module provides authentication utilities for a web application, including user loading and password hashing. It utilizes the Passlib library for secure password hashing and integrates with the application's login management system to retrieve users based on their email address.</p>"},{"location":"services/auth/#services.auth.get_user","title":"<code>get_user(email)</code>","text":"<p>Retrieves a user from the database by their email address.</p> <p>This function is decorated with @login_manager.user_loader, indicating it's used by Flask-Login to load a user from a session. It queries the database for a user with the given email and returns the user object if found.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email address of the user to retrieve.</p> required <p>Returns:</p> Name Type Description <code>User</code> <p>The user object if found, otherwise None.</p> Source code in <code>services/auth.py</code> <pre><code>@login_manager.user_loader()\ndef get_user(email: str):\n    \"\"\"\n    Retrieves a user from the database by their email address.\n\n    This function is decorated with @login_manager.user_loader, indicating it's used by Flask-Login to load a user from a session.\n    It queries the database for a user with the given email and returns the user object if found.\n\n    Args:\n        email (str): The email address of the user to retrieve.\n\n    Returns:\n        User: The user object if found, otherwise None.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        return db.query(User).filter(User.email == email).first()\n    finally:\n        db.close()\n</code></pre>"},{"location":"services/auth/#services.auth.hash_password","title":"<code>hash_password(password)</code>","text":"<p>Hashes a password using the bcrypt algorithm.</p> <p>This function uses Passlib's CryptContext for secure password hashing. The 'bcrypt' scheme is specified, with 'deprecated' set to 'auto' to automatically handle deprecated hash formats.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The plaintext password to hash.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hashed password.</p> Source code in <code>services/auth.py</code> <pre><code>def hash_password(password: str) -&gt; str:\n    \"\"\"\n    Hashes a password using the bcrypt algorithm.\n\n    This function uses Passlib's CryptContext for secure password hashing. The 'bcrypt' scheme is specified, with 'deprecated' set to 'auto' to automatically handle deprecated hash formats.\n\n    Args:\n        password (str): The plaintext password to hash.\n\n    Returns:\n        str: The hashed password.\n    \"\"\"\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n    return pwd_context.hash(password)\n</code></pre>"},{"location":"services/favorites/","title":"Documentation for <code>services/favorites.py</code>","text":"<p>This module provides functionality to interact with the MusicLibrary database, specifically for retrieving song IDs based on file paths. It includes a function that queries the MusicLibrary table to find a song by its file path and return the song's ID.</p>"},{"location":"services/favorites/#services.favorites.get_song_id_by_filepath","title":"<code>get_song_id_by_filepath(db, file_path)</code>","text":"<p>Retrieves the ID of a song from the MusicLibrary table based on its file path.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The SQLAlchemy session for database access.</p> required <code>file_path</code> <code>SongPath</code> <p>The file path of the song.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ID of the song if found, otherwise None.</p> Source code in <code>services/favorites.py</code> <pre><code>def get_song_id_by_filepath(db: Session, file_path: SongPath) -&gt; int:\n    \"\"\"\n    Retrieves the ID of a song from the MusicLibrary table based on its file path.\n\n    Args:\n        db (Session): The SQLAlchemy session for database access.\n        file_path (SongPath): The file path of the song.\n\n    Returns:\n        int: The ID of the song if found, otherwise None.\n    \"\"\"\n    song = db.query(MusicLibrary).filter(MusicLibrary.filepath == file_path).first()\n    if song:\n        return song.id\n    else:\n        return None\n</code></pre>"},{"location":"services/lyrics/","title":"Documentation for <code>services/lyrics.py</code>","text":"<p>This module provides a function to fetch song lyrics using the Lyrics.ovh API. It includes error handling for request failures and cases where lyrics are not found.</p>"},{"location":"services/lyrics/#services.lyrics.fetch_lyrics","title":"<code>fetch_lyrics(artist, title)</code>","text":"<p>Fetches the lyrics for a given song by artist and title.</p> <p>Parameters:</p> Name Type Description Default <code>artist</code> <code>str</code> <p>The name of the artist.</p> required <code>title</code> <code>str</code> <p>The title of the song.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The lyrics of the song if found, otherwise a message indicating no lyrics were found.</p> Source code in <code>services/lyrics.py</code> <pre><code>def fetch_lyrics(artist: str, title: str) -&gt; str:\n    \"\"\"\n    Fetches the lyrics for a given song by artist and title.\n\n    Args:\n        artist (str): The name of the artist.\n        title (str): The title of the song.\n\n    Returns:\n        str: The lyrics of the song if found, otherwise a message indicating no lyrics were found.\n    \"\"\"\n    encoded_artist = urllib.parse.quote(artist)\n    encoded_song = urllib.parse.quote(title)\n    try:\n        response = requests.get(f\"https://api.lyrics.ovh/v1/{encoded_artist}/{encoded_song}\", timeout=7)\n        response.raise_for_status()\n    except requests.exceptions.RequestException:\n        return \"No lyrics found for this song.\"\n\n    json_response = response.json()\n    if 'error' in json_response:\n        return \"No lyrics found for this song.\"\n    return json_response['lyrics']\n</code></pre>"},{"location":"services/milvus/","title":"Documentation for <code>services/milvus.py</code>","text":"<p>This Python module provides a comprehensive suite of functionalities for interacting with the Milvus vector database, specifically tailored for managing and querying music-related data.  It includes capabilities for connecting to Milvus, performing queries, and processing the results for further analysis or visualization.  Additionally, it offers utilities for generating visual representations of data, such as genre predictions for music tracks, and converting these visualizations into a format suitable for web display.</p>"},{"location":"services/milvus/#services.milvus.convert_plot_to_base64","title":"<code>convert_plot_to_base64(fig)</code>  <code>async</code>","text":"<p>Converts a matplotlib plot to a base64-encoded string for embedding in web pages or other digital formats.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <p>The matplotlib figure to convert.</p> required <p>Returns:</p> Type Description <p>A base64-encoded string representing the plot image.</p> Source code in <code>services/milvus.py</code> <pre><code>async def convert_plot_to_base64(fig):\n    \"\"\"\n    Converts a matplotlib plot to a base64-encoded string for embedding in web pages or other digital formats.\n\n    Args:\n        fig: The matplotlib figure to convert.\n\n    Returns:\n        A base64-encoded string representing the plot image.\n    \"\"\"\n    buf = io.BytesIO()\n    fig.savefig(buf, format='png')\n    buf.seek(0)\n    image_base64 = base64.b64encode(buf.read()).decode('utf-8')\n    return image_base64\n</code></pre>"},{"location":"services/milvus/#services.milvus.create_plot","title":"<code>create_plot(class_names, top_5_activations, title, artist)</code>  <code>async</code>","text":"<p>Generates a horizontal bar plot visualizing the top 5 music genre predictions for a given track.</p> <p>Parameters:</p> Name Type Description Default <code>class_names</code> <code>List[str]</code> <p>The names of the top 5 predicted genres.</p> required <code>top_5_activations</code> <code>List[float]</code> <p>The activation values for the top 5 predicted genres.</p> required <code>title</code> <code>str</code> <p>The title of the music track.</p> required <code>artist</code> <code>str</code> <p>The artist of the music track.</p> required <p>Returns:</p> Type Description <p>A matplotlib figure object containing the generated plot.</p> Source code in <code>services/milvus.py</code> <pre><code>async def create_plot(class_names: List[str], top_5_activations: List[float], title: str, artist: str):\n    \"\"\"\n    Generates a horizontal bar plot visualizing the top 5 music genre predictions for a given track.\n\n    Args:\n        class_names: The names of the top 5 predicted genres.\n        top_5_activations: The activation values for the top 5 predicted genres.\n        title: The title of the music track.\n        artist: The artist of the music track.\n\n    Returns:\n        A matplotlib figure object containing the generated plot.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(6, 2))\n    plt.barh(class_names, top_5_activations, color='#60a5fa', edgecolor='#cbd5e1')\n    plt.title(f'Genres for {title} by {artist}', color='#cbd5e1')\n    plt.tick_params(colors='#cbd5e1')\n    ax.set_facecolor('#111827')\n    fig.patch.set_facecolor('#111827')\n    return fig\n</code></pre>"},{"location":"services/milvus/#services.milvus.extract_plot_data","title":"<code>extract_plot_data(entity)</code>  <code>async</code>","text":"<p>Extracts data from a single entity for the purpose of generating a genre prediction plot.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <p>The entity from which to extract plot data.</p> required <p>Returns:</p> Type Description <p>A tuple containing class names, top 5 activations, title, and artist, ready for plotting.</p> Source code in <code>services/milvus.py</code> <pre><code>async def extract_plot_data(entity):\n    \"\"\"\n    Extracts data from a single entity for the purpose of generating a genre prediction plot.\n\n    Args:\n        entity: The entity from which to extract plot data.\n\n    Returns:\n        A tuple containing class names, top 5 activations, title, and artist, ready for plotting.\n    \"\"\"\n    embeddings = entity[0][\"predictions\"]\n    title = entity[0][\"title\"]\n    artist = entity[0][\"artist\"]\n\n    with open('core/data/mtg_jamendo_genre.json', 'r') as json_file:\n        metadata = json.load(json_file)\n\n    classes = metadata.get('classes')\n    embeddings = np.array(embeddings)\n    if len(embeddings.shape) == 1:\n        embeddings = embeddings.reshape(1, -1)\n\n    average_activations = np.mean(embeddings, axis=0)\n    average_activations_float = average_activations.astype(np.float32)\n    sorted_indices = np.argsort(average_activations_float)\n    top_5_classes = sorted_indices[-5:]\n    top_5_activations = average_activations[top_5_classes]\n    class_names = np.array(classes)[top_5_classes]\n\n    return class_names, top_5_activations, title, artist\n</code></pre>"},{"location":"services/milvus/#services.milvus.full_hit_to_dict","title":"<code>full_hit_to_dict(hit)</code>","text":"<p>Converts the full details of a Milvus query hit into a dictionary format, including all available entity information.</p> <p>Parameters:</p> Name Type Description Default <code>hit</code> <p>The query hit object returned by Milvus.</p> required <p>Returns:</p> Type Description <p>A dictionary containing detailed information about the query hit.</p> Source code in <code>services/milvus.py</code> <pre><code>def full_hit_to_dict(hit):\n    \"\"\"\n    Converts the full details of a Milvus query hit into a dictionary format, including all available entity information.\n\n    Args:\n        hit: The query hit object returned by Milvus.\n\n    Returns:\n        A dictionary containing detailed information about the query hit.\n    \"\"\"\n    return {\n        \"id\": str(hit.id),\n        \"distance\": hit.distance,\n        \"entity\": {\n            \"path\": hit.entity.path,\n            \"title\": hit.entity.title,\n            \"album\": hit.entity.album,\n            \"artist\": hit.entity.artist,\n            \"top_5_genres\": \",\".join(hit.entity.top_5_genres),\n            \"embedding\": \",\".join(map(str, hit.entity.embedding)),\n        },\n    }\n</code></pre>"},{"location":"services/milvus/#services.milvus.get_milvus_512_collection","title":"<code>get_milvus_512_collection()</code>","text":"<p>Connects to the Milvus database and retrieves the collection specified for 512-dimensional vectors.</p> <p>Returns:</p> Type Description <p>The Milvus Collection object corresponding to the 512-dimensional vector collection.</p> Source code in <code>services/milvus.py</code> <pre><code>def get_milvus_512_collection():\n    \"\"\"\n    Connects to the Milvus database and retrieves the collection specified for 512-dimensional vectors.\n\n    Returns:\n        The Milvus Collection object corresponding to the 512-dimensional vector collection.\n    \"\"\"\n    connections.connect(\n        \"default\",\n        uri=DEFAULT_SETTINGS.milvus_uri,\n        token=DEFAULT_SETTINGS.milvus_api_key,\n    )\n    return Collection(name=DEFAULT_SETTINGS.milvus_512_collection_name)\n</code></pre>"},{"location":"services/milvus/#services.milvus.get_milvus_87_collection","title":"<code>get_milvus_87_collection()</code>","text":"<p>Connects to the Milvus database and retrieves the collection specified for 87-dimensional vectors.</p> <p>Returns:</p> Type Description <p>The Milvus Collection object corresponding to the 87-dimensional vector collection.</p> Source code in <code>services/milvus.py</code> <pre><code>def get_milvus_87_collection():\n    \"\"\"\n    Connects to the Milvus database and retrieves the collection specified for 87-dimensional vectors.\n\n    Returns:\n        The Milvus Collection object corresponding to the 87-dimensional vector collection.\n    \"\"\"\n    connections.connect(\n        \"default\",\n        uri=DEFAULT_SETTINGS.milvus_uri,\n        token=DEFAULT_SETTINGS.milvus_api_key,\n    )\n    return Collection(name=DEFAULT_SETTINGS.milvus_87_collection_name)\n</code></pre>"},{"location":"services/milvus/#services.milvus.ping_milvus","title":"<code>ping_milvus()</code>","text":"<p>Attempts to connect to the Milvus database using settings from the configuration and performs a simple query to check if the connection is successful.</p> <p>Returns:</p> Type Description <p>A dictionary with a status message indicating the outcome of the connection attempt.</p> Source code in <code>services/milvus.py</code> <pre><code>def ping_milvus():\n    \"\"\"\n    Attempts to connect to the Milvus database using settings from the configuration and performs a simple query to check if the connection is successful.\n\n    Returns:\n        A dictionary with a status message indicating the outcome of the connection attempt.\n    \"\"\"\n    try:\n        connections.connect(\n            \"default\",\n            uri=DEFAULT_SETTINGS.milvus_uri,\n            token=DEFAULT_SETTINGS.milvus_api_key,\n        )\n        embedding_512 = Collection(name=DEFAULT_SETTINGS.milvus_512_collection_name)\n        response = embedding_512.query(\n            expr=\"id in [0]\",\n            output_fields=[\"artist\"],\n        )\n        if response:\n            return {\"status\": \"success\", \"message\": \"Milvus is running\"}\n    except Exception as e:\n        return {\"status\": \"error\", \"message\": str(e)}\n</code></pre>"},{"location":"services/milvus/#services.milvus.short_hit_to_dict","title":"<code>short_hit_to_dict(hit)</code>","text":"<p>Converts a Milvus query hit into a simplified dictionary format, focusing on essential metadata.</p> <p>Parameters:</p> Name Type Description Default <code>hit</code> <p>The query hit object returned by Milvus.</p> required <p>Returns:</p> Type Description <p>A simplified dictionary containing key information about the query hit.</p> Source code in <code>services/milvus.py</code> <pre><code>def short_hit_to_dict(hit):\n    \"\"\"\n    Converts a Milvus query hit into a simplified dictionary format, focusing on essential metadata.\n\n    Args:\n        hit: The query hit object returned by Milvus.\n\n    Returns:\n        A simplified dictionary containing key information about the query hit.\n    \"\"\"\n    return {\n        \"title\": hit.entity.title,\n        \"album\": hit.entity.album,\n        \"artist\": hit.entity.artist,\n        \"path\": hit.entity.path,\n    }\n</code></pre>"},{"location":"services/milvus/#services.milvus.sort_entities","title":"<code>sort_entities(entities)</code>","text":"<p>Sorts a list of entities based on artist uniqueness to prioritize diversity in recommendations.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <p>A list of entities (query hits) to be sorted.</p> required <p>Returns:</p> Type Description <p>A sorted list of entities with unique artists prioritized.</p> Source code in <code>services/milvus.py</code> <pre><code>def sort_entities(entities):\n    \"\"\"\n    Sorts a list of entities based on artist uniqueness to prioritize diversity in recommendations.\n\n    Args:\n        entities: A list of entities (query hits) to be sorted.\n\n    Returns:\n        A sorted list of entities with unique artists prioritized.\n    \"\"\"\n    recommended_artists = set()\n    response_list = []\n    fallback_list = []\n    for hit in entities[0]:\n        hit_dict = short_hit_to_dict(hit)\n        if hit_dict[\"artist\"] not in recommended_artists:\n            response_list.append(hit_dict)\n            recommended_artists.add(hit_dict[\"artist\"])\n        else:\n            fallback_list.append(hit_dict)\n        if len(response_list) == 9:  # Stop when we have 9 results\n            break\n    if len(response_list) &lt; 9:\n        response_list.extend(fallback_list[:9-len(response_list)])\n    return response_list\n</code></pre>"},{"location":"services/minio/","title":"Documentation for <code>services/minio.py</code>","text":"<p>This module provides utilities for interacting with MinIO, including functions for loading models, managing temporary files, converting artwork to base64, and sanitizing filenames.</p>"},{"location":"services/minio/#services.minio.convert_artwork_to_base64","title":"<code>convert_artwork_to_base64(artwork)</code>","text":"<p>Converts artwork data to a base64-encoded string.</p> <p>Parameters:</p> Name Type Description Default <code>artwork</code> <p>The artwork data.</p> required <p>Returns:</p> Type Description <p>str or None: The base64-encoded string, or None if artwork is None.</p> Source code in <code>services/minio.py</code> <pre><code>def convert_artwork_to_base64(artwork):\n    \"\"\"\n    Converts artwork data to a base64-encoded string.\n\n    Args:\n        artwork: The artwork data.\n\n    Returns:\n        str or None: The base64-encoded string, or None if artwork is None.\n    \"\"\"\n    if artwork is not None:\n        return base64.b64encode(artwork.data).decode('utf-8')\n    return None\n</code></pre>"},{"location":"services/minio/#services.minio.delete_temp_file","title":"<code>delete_temp_file(temp_file_path)</code>","text":"<p>Deletes a temporary file.</p> <p>Parameters:</p> Name Type Description Default <code>temp_file_path</code> <code>str</code> <p>The path to the temporary file to delete.</p> required Source code in <code>services/minio.py</code> <pre><code>def delete_temp_file(temp_file_path: str):\n    \"\"\"\n    Deletes a temporary file.\n\n    Args:\n        temp_file_path (str): The path to the temporary file to delete.\n    \"\"\"\n    os.unlink(temp_file_path)\n</code></pre>"},{"location":"services/minio/#services.minio.get_artwork","title":"<code>get_artwork(bucket_name, file_name)</code>","text":"<p>Retrieves artwork from a specified bucket and file name, converts it to base64.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the bucket.</p> required <code>file_name</code> <code>str</code> <p>The name of the file.</p> required <p>Returns:</p> Type Description <p>str or None: The base64-encoded artwork, or None if not found or an error occurs.</p> Source code in <code>services/minio.py</code> <pre><code>def get_artwork(bucket_name: str, file_name: str):\n    \"\"\"\n    Retrieves artwork from a specified bucket and file name, converts it to base64.\n\n    Args:\n        bucket_name (str): The name of the bucket.\n        file_name (str): The name of the file.\n\n    Returns:\n        str or None: The base64-encoded artwork, or None if not found or an error occurs.\n    \"\"\"\n    try:\n        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n            try:\n                data = minio_client.get_object(bucket_name, file_name)\n                temp_file.write(data.read())\n            except S3Error as e:\n                if e.code == 'NoSuchKey':\n                    print(f\"File {file_name} not found in bucket {bucket_name}.\")\n                    return None\n                else:\n                    raise\n        f = music_tag.load_file(temp_file.name)\n        if f['artwork'] and f['artwork'].first is not None:\n            return convert_artwork_to_base64(f['artwork'].first)\n        return None\n    finally:\n        os.unlink(temp_file.name)\n</code></pre>"},{"location":"services/minio/#services.minio.get_metadata_and_artwork","title":"<code>get_metadata_and_artwork(bucket_name, file_name)</code>","text":"<p>Retrieves metadata and artwork for a given file from MinIO, converting artwork to base64.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the bucket.</p> required <code>file_name</code> <code>str</code> <p>The name of the file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the metadata and base64-encoded artwork.</p> Source code in <code>services/minio.py</code> <pre><code>def get_metadata_and_artwork(bucket_name: str, file_name: str):\n    \"\"\"\n    Retrieves metadata and artwork for a given file from MinIO, converting artwork to base64.\n\n    Args:\n        bucket_name (str): The name of the bucket.\n        file_name (str): The name of the file.\n\n    Returns:\n        dict: A dictionary containing the metadata and base64-encoded artwork.\n    \"\"\"\n    with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n        data = minio_client.get_object(bucket_name, file_name)\n        temp_file.write(data.read())\n\n    try:\n        f = music_tag.load_file(temp_file.name)\n        metadata = {\n            \"filepath\": file_name,\n            \"filesize\": round(os.path.getsize(temp_file.name) / 1024 / 1024, 2),\n            \"title\": f['title'].first or \"Unknown Title\",\n            \"artist\": f['artist'].first or \"Unknown Artist\",\n            \"album\": f['album'].first or \"Unknown Album\",\n            \"year\": f['year'].first or \"Unknown Year\",\n            \"tracknumber\": f['tracknumber'].first or \"Unknown Track Number\",\n            \"genre\": f['genre'].first or \"Unknown Genre\",\n        }\n        if f['artwork'] and f['artwork'].first is not None:\n            metadata[\"artwork\"] = convert_artwork_to_base64(f['artwork'].first)\n        return metadata\n    finally:\n        os.unlink(temp_file.name)\n</code></pre>"},{"location":"services/minio/#services.minio.get_temp_file_from_minio","title":"<code>get_temp_file_from_minio(file_name)</code>","text":"<p>Retrieves a file from MinIO and writes it to a temporary file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to retrieve.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The path to the temporary file.</p> Source code in <code>services/minio.py</code> <pre><code>def get_temp_file_from_minio(file_name: str):\n    \"\"\"\n    Retrieves a file from MinIO and writes it to a temporary file.\n\n    Args:\n        file_name (str): The name of the file to retrieve.\n\n    Returns:\n        str: The path to the temporary file.\n    \"\"\"\n    with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n        response = minio_client.get_object(DEFAULT_SETTINGS.minio_temp_bucket_name, file_name)\n        temp_file.write(response.read())\n    return temp_file.name\n</code></pre>"},{"location":"services/minio/#services.minio.load_model_from_minio","title":"<code>load_model_from_minio()</code>","text":"<p>Loads a model from MinIO into a temporary file and returns the model.</p> <p>Returns:</p> Name Type Description <code>EmbeddingsOpenL3</code> <p>The loaded model.</p> Source code in <code>services/minio.py</code> <pre><code>def load_model_from_minio():\n    \"\"\"\n    Loads a model from MinIO into a temporary file and returns the model.\n\n    Returns:\n        EmbeddingsOpenL3: The loaded model.\n    \"\"\"\n    with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n        response = minio_client.get_object(DEFAULT_SETTINGS.minio_openl3_bucket_name, DEFAULT_SETTINGS.minio_openl3_file_name)\n        temp_file.write(response.read())\n        temp_file.flush()\n        embedding_512_model = EmbeddingsOpenL3(graph_path=temp_file.name)\n    return embedding_512_model\n</code></pre>"},{"location":"services/minio/#services.minio.sanitize_filename","title":"<code>sanitize_filename(filename)</code>","text":"<p>Sanitizes a filename by removing disallowed characters and sequences.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to sanitize.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The sanitized filename.</p> Source code in <code>services/minio.py</code> <pre><code>def sanitize_filename(filename):\n    \"\"\"\n    Sanitizes a filename by removing disallowed characters and sequences.\n\n    Args:\n        filename (str): The filename to sanitize.\n\n    Returns:\n        str: The sanitized filename.\n    \"\"\"\n    replacements = {\n        \"!\": \"\", \"@\": \"\", \"#\": \"\", \"$\": \"\", \"%\": \"\", \"^\": \"\", \"&amp;\": \"\", \"*\": \"\", \"(\": \"\", \")\": \"\",\n        \"[\": \"\", \"]\": \"\", \"{\": \"\", \"}\": \"\", \";\": \"\", \":\": \"\", \"\\\"\": \"\", \"'\": \"\", \",\": \"\", \"&lt;\": \"\",\n        \"&gt;\": \"\", \"/\": \"\", \"?\": \"\", \"`\": \"\", \"~\": \"\",\n        \"\u00e9\": \"e\", \"\u00e8\": \"e\", \"\u00ea\": \"e\", \"\u00e0\": \"a\", \"\u00e2\": \"a\", \"\u00f9\": \"u\", \"\u00f4\": \"o\", \"\u00ee\": \"i\", \"\u00e7\": \"c\", \"\u00eb\": \"e\"\n    }\n    has_mp3_extension = filename.lower().endswith('.mp3')\n    if has_mp3_extension:\n        base_name, extension = filename[:-4], filename[-4:]\n    else:\n        base_name, extension = filename, ''\n    base_name = base_name.replace(\"..\", \"\").replace(\"//\", \"\")\n    sanitized_base_name = \"\".join(replacements.get(c, c) for c in base_name if c not in [' '] and (c.isalnum() or c in replacements))\n    if has_mp3_extension:\n        sanitized_base_name = sanitized_base_name.rstrip(\".\")\n    sanitized = sanitized_base_name + extension\n    if not sanitized:\n        raise ValueError(\"Filename cannot be empty.\")\n    return sanitized\n</code></pre>"},{"location":"services/monitoring/","title":"Documentation for <code>services/monitoring.py</code>","text":"<p>This module provides functions to monitor various system statistics on a Linux machine, including CPU temperature, CPU usage, memory usage, and disk usage.</p>"},{"location":"services/monitoring/#services.monitoring.get_all_pi_stats","title":"<code>get_all_pi_stats()</code>","text":"<p>Gathers all Raspberry Pi statistics including CPU temperature, CPU usage, memory usage, and disk usage.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing all the Raspberry Pi statistics.</p> Source code in <code>services/monitoring.py</code> <pre><code>def get_all_pi_stats():\n    \"\"\"\n    Gathers all Raspberry Pi statistics including CPU temperature, CPU usage, memory usage, and disk usage.\n\n    Returns:\n        dict: A dictionary containing all the Raspberry Pi statistics.\n    \"\"\"\n    return {\n        \"cpu_temperature\": get_pi_cpu_temperature(),\n        \"cpu_usage\": get_pi_cpu_usage(),\n        \"memory_usage\": get_pi_memory_usage(),\n        \"disk_usage\": get_pi_disk_usage()\n    }\n</code></pre>"},{"location":"services/monitoring/#services.monitoring.get_pi_cpu_temperature","title":"<code>get_pi_cpu_temperature()</code>","text":"<p>Gets the current CPU temperature of the Raspberry Pi.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The current CPU temperature in degrees Celsius.</p> Source code in <code>services/monitoring.py</code> <pre><code>def get_pi_cpu_temperature():\n    \"\"\"\n    Gets the current CPU temperature of the Raspberry Pi.\n\n    Returns:\n        float: The current CPU temperature in degrees Celsius.\n    \"\"\"\n    with open('/sys/class/thermal/thermal_zone0/temp') as f:\n        temp = f.read()\n    return round(float(temp) / 1000, 2)\n</code></pre>"},{"location":"services/monitoring/#services.monitoring.get_pi_cpu_usage","title":"<code>get_pi_cpu_usage()</code>","text":"<p>Calculates the current CPU usage of the Raspberry Pi.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The current CPU usage as a percentage.</p> Source code in <code>services/monitoring.py</code> <pre><code>def get_pi_cpu_usage():\n    \"\"\"\n    Calculates the current CPU usage of the Raspberry Pi.\n\n    Returns:\n        float: The current CPU usage as a percentage.\n    \"\"\"\n    with open('/proc/stat', 'r') as f:\n        line = f.readline()\n    stats = line.split()\n    total = sum(int(i) for i in stats[1:])\n    idle = int(stats[4])\n    usage = ((total - idle) / total) * 100\n    return round(usage, 2)\n</code></pre>"},{"location":"services/monitoring/#services.monitoring.get_pi_disk_usage","title":"<code>get_pi_disk_usage()</code>","text":"<p>Calculates the current disk usage of the Raspberry Pi.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The current disk usage as a percentage of total disk space.</p> Source code in <code>services/monitoring.py</code> <pre><code>def get_pi_disk_usage():\n    \"\"\"\n    Calculates the current disk usage of the Raspberry Pi.\n\n    Returns:\n        float: The current disk usage as a percentage of total disk space.\n    \"\"\"\n    disk = subprocess.check_output(['df', '-h', '/']).decode()\n    disk_usage_percentage = disk.split('\\n')[1].split()[4]\n    return float(disk_usage_percentage.rstrip('%'))\n</code></pre>"},{"location":"services/monitoring/#services.monitoring.get_pi_memory_usage","title":"<code>get_pi_memory_usage()</code>","text":"<p>Calculates the current memory usage of the Raspberry Pi.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The current memory usage as a percentage of total memory.</p> Source code in <code>services/monitoring.py</code> <pre><code>def get_pi_memory_usage():\n    \"\"\"\n    Calculates the current memory usage of the Raspberry Pi.\n\n    Returns:\n        float: The current memory usage as a percentage of total memory.\n    \"\"\"\n    mem = subprocess.check_output(['cat', '/proc/meminfo']).decode()\n    total_memory = int(mem.split('\\n')[0].split()[1]) / 1024  # Convert from KB to MB\n    available_memory = int(mem.split('\\n')[2].split()[1]) / 1024  # Convert from KB to MB\n    memory_usage_percentage = ((total_memory - available_memory) / total_memory) * 100\n    return round(memory_usage_percentage, 2)\n</code></pre>"},{"location":"services/openl3/","title":"Documentation for <code>services/openl3.py</code>","text":"<p>This module is designed to extract audio embeddings using the OpenL3 model. It handles the extraction of embeddings from audio files stored in MinIO.</p>"},{"location":"services/openl3/#services.openl3.extract_embeddings","title":"<code>extract_embeddings(file_path)</code>","text":"<p>Extracts embeddings from an audio file using the OpenL3 model.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the audio file from which to extract embeddings.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list representing the extracted embeddings.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the file cannot be found or an error occurs during the embedding extraction process.</p> Source code in <code>services/openl3.py</code> <pre><code>def extract_embeddings(file_path: str):\n    \"\"\"\n    Extracts embeddings from an audio file using the OpenL3 model.\n\n    Args:\n        file_path (str): The path to the audio file from which to extract embeddings.\n\n    Returns:\n        list: A list representing the extracted embeddings.\n\n    Raises:\n        Exception: If the file cannot be found or an error occurs during the embedding extraction process.\n    \"\"\"\n    try:\n        # Load the OpenL3 model from MinIO\n        embedding_512_model = load_model_from_minio()\n        # Obtain a temporary file path for the audio file from MinIO\n        temp_file_path = get_temp_file_from_minio(DEFAULT_SETTINGS.minio_openl3_bucket_name, file_path)\n\n        # Compute embeddings using the temporary file path\n        vector = embedding_512_model.compute(temp_file_path)\n        embedding = vector.mean(axis=0)\n\n        # Clean up the temporary file\n        os.unlink(temp_file_path)\n\n        return embedding.tolist()\n\n    except Exception as e:\n        raise Exception(f\"File not found: {e}\")\n</code></pre>"},{"location":"services/spotinite/","title":"Documentation for <code>services/spotinite.py</code>","text":"<p>This module integrates the Spotify Web API through the Spotipy client and the Cyanite.ai API to provide functionalities such as searching for a track by name and artist, fetching similar tracks based on a Spotify track ID, and retrieving detailed information about a track. It is designed to facilitate the exploration and recommendation of music tracks by leveraging the capabilities of both Spotify and Cyanite.ai services.</p>"},{"location":"services/spotinite/#services.spotinite.fetch_similar_tracks","title":"<code>fetch_similar_tracks(spotify_id)</code>","text":"<p>Fetches similar tracks from the Cyanite.ai API based on a given Spotify track ID.</p> <p>Parameters:</p> Name Type Description Default <code>spotify_id</code> <code>str</code> <p>The Spotify ID of the track for which similar tracks are to be found.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of Spotify IDs for tracks similar to the given track.</p> Source code in <code>services/spotinite.py</code> <pre><code>def fetch_similar_tracks(spotify_id: str) -&gt; list:\n    \"\"\"\n    Fetches similar tracks from the Cyanite.ai API based on a given Spotify track ID.\n\n    Args:\n        spotify_id (str): The Spotify ID of the track for which similar tracks are to be found.\n\n    Returns:\n        list: A list of Spotify IDs for tracks similar to the given track.\n    \"\"\"\n    url = \"https://api.cyanite.ai/graphql\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {DEFAULT_SETTINGS.cyanite_token}\",\n    }\n    query = \"\"\"\n    query SimilarTracksQuery($trackId: ID!) {\n      spotifyTrack(id: $trackId) {\n        __typename\n        ... on Error {\n          message\n        }\n        ... on Track {\n          id\n          similarTracks(target: { spotify: {} }, first: 15) {\n            __typename\n            ... on SimilarTracksError {\n              code\n              message\n            }\n            ... on SimilarTracksConnection {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \"\"\"\n    variables = {\"trackId\": spotify_id}\n    response = requests.post(url, headers=headers, json={\"query\": query, \"variables\": variables})\n    data = response.json()\n\n    if 'edges' in data['data']['spotifyTrack']['similarTracks']:\n        edges = data['data']['spotifyTrack']['similarTracks']['edges']\n        track_ids = [edge['node']['id'] for edge in edges]\n        return track_ids\n    else:\n        return []\n</code></pre>"},{"location":"services/spotinite/#services.spotinite.get_track_id","title":"<code>get_track_id(song_name, artist)</code>","text":"<p>Searches for a song on Spotify by name and artist and returns the Spotify ID of the first result.</p> <p>Parameters:</p> Name Type Description Default <code>song_name</code> <code>str</code> <p>The name of the song.</p> required <code>artist</code> <code>str</code> <p>The name of the artist.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Spotify ID of the song.</p> Source code in <code>services/spotinite.py</code> <pre><code>def get_track_id(song_name: str, artist: str) -&gt; str:\n    \"\"\"\n    Searches for a song on Spotify by name and artist and returns the Spotify ID of the first result.\n\n    Args:\n        song_name (str): The name of the song.\n        artist (str): The name of the artist.\n\n    Returns:\n        str: The Spotify ID of the song.\n    \"\"\"\n    results = sp.search(q=f'track:{song_name} artist:{artist}', type='track')\n    spotify_id = results['tracks']['items'][0]['id']\n    return spotify_id\n</code></pre>"},{"location":"services/spotinite/#services.spotinite.get_track_info","title":"<code>get_track_info(track_id)</code>","text":"<p>Retrieves detailed information about a track from Spotify using its Spotify ID.</p> <p>Parameters:</p> Name Type Description Default <code>track_id</code> <code>str</code> <p>The Spotify ID of the track.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing detailed information about the track, including its name, artist, album, URI, and cover image URL.</p> Source code in <code>services/spotinite.py</code> <pre><code>def get_track_info(track_id: str) -&gt; dict:\n    \"\"\"\n    Retrieves detailed information about a track from Spotify using its Spotify ID.\n\n    Args:\n        track_id (str): The Spotify ID of the track.\n\n    Returns:\n        dict: A dictionary containing detailed information about the track, including its name, artist, album, URI, and cover image URL.\n    \"\"\"\n    track_info = sp.track(track_id)\n    track_name = track_info['name']\n    artist_name = track_info['artists'][0]['name']\n    album_name = track_info['album']['name']\n    uri = track_info['uri']\n    cover_image = track_info['album']['images'][0]['url']\n    return {\n        \"Track Name\": track_name,\n        \"Artist\": artist_name,\n        \"Album\": album_name,\n        \"URI\": uri,\n        \"Cover Image\": cover_image\n    }\n</code></pre>"},{"location":"services/uploaded/","title":"Documentation for <code>services/uploaded.py</code>","text":"<p>This module provides functionalities to interact with a MiniO bucket for storing and retrieving user uploaded songs.</p>"},{"location":"services/uploaded/#services.uploaded.get_user_uploads","title":"<code>get_user_uploads(db, user_id)</code>","text":"<p>Retrieves all files uploaded by a specific user.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The SQLAlchemy session object.</p> required <code>user_id</code> <code>int</code> <p>The ID of the user whose uploads are to be retrieved.</p> required <p>Returns:</p> Type Description <p>list[dict]: A list of dictionaries, each containing the filename of an uploaded file.</p> Source code in <code>services/uploaded.py</code> <pre><code>def get_user_uploads(db: Session, user_id: int):\n    \"\"\"\n    Retrieves all files uploaded by a specific user.\n\n    Args:\n        db (Session): The SQLAlchemy session object.\n        user_id (int): The ID of the user whose uploads are to be retrieved.\n\n    Returns:\n        list[dict]: A list of dictionaries, each containing the filename of an uploaded file.\n    \"\"\"\n    uploaded_files = db.query(UserUploaded).filter(UserUploaded.user_id == user_id).all()\n    return [{\"filename\": file.filename} for file in uploaded_files]\n</code></pre>"},{"location":"services/uploaded/#services.uploaded.store_upload_info","title":"<code>store_upload_info(db, user_id, filename)</code>","text":"<p>Stores information about a file uploaded by a user in the database if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>The SQLAlchemy session object.</p> required <code>user_id</code> <code>int</code> <p>The ID of the user who uploaded the file.</p> required <code>filename</code> <code>str</code> <p>The name of the uploaded file.</p> required <p>This function checks if an entry with the given user ID and filename already exists in the database. If not, it creates a new entry and commits it to the database.</p> Source code in <code>services/uploaded.py</code> <pre><code>def store_upload_info(db: Session, user_id: int, filename: str):\n    \"\"\"\n    Stores information about a file uploaded by a user in the database if it does not already exist.\n\n    Args:\n        db (Session): The SQLAlchemy session object.\n        user_id (int): The ID of the user who uploaded the file.\n        filename (str): The name of the uploaded file.\n\n    This function checks if an entry with the given user ID and filename already exists in the database.\n    If not, it creates a new entry and commits it to the database.\n    \"\"\"\n    existing_entry = db.query(UserUploaded).filter_by(user_id=user_id, filename=filename).first()\n\n    if not existing_entry:\n        upload_entry = UserUploaded(user_id=user_id, filename=filename)\n        db.add(upload_entry)\n        db.commit()\n</code></pre>"}]}