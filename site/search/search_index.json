{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MegaPi Welcome to MegaPi, the dynamic backend API powering the music sim web application. Engineered to revolutionize the way users explore music, MegaPi delivers personalized song recommendations with unparalleled accuracy. At its core, MegaPi harnesses the power of the Milvus vector database and sophisticated single feature vectors, crafted using an Essentia CNN specifically trained for music genre classification. Coupled with the robust MinIO object storage system, MegaPi provides a seamless and innovative solution for navigating through an extensive music library, ensuring every user experience is both unique and engaging. Runs in a Docker container docker compose up -d docker ps --format 'table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Status}}\\t{{.Names}}' NAMES PORTS megapi-megapi-1 8000:8000 megapi-minio-1 9000:9001 megapi-postgre-1 5432:5432 Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. . \u251c\u2500\u2500 app.py \u251c\u2500\u2500 docker-compose.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 core \u2502 \u251c\u2500\u2500 data \u2502 \u2502 \u251c\u2500\u2500 mtg_jamendo_genre.json \u2502 \u2502 \u2514\u2500\u2500 music.db \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 database.py \u2502 \u251c\u2500\u2500 extract_openl3_embeddings.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 extract_openl3_embeddings.py \u2502 \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 endpoints \u2502 \u251c\u2500\u2500 index.md \u2502 \u2514\u2500\u2500 services \u2502 \u251c\u2500\u2500 gui \u2502 \u2514\u2500\u2500 templates \u2502 \u2514\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 favorites.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u251c\u2500\u2500 openl3.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u251c\u2500\u2500 uploaded.py \u2502 \u2514\u2500\u2500 users.py \u2502 \u251c\u2500\u2500 routes \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 favorites.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 monitoring.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u251c\u2500\u2500 openl3.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 uploaded.py \u2502 \u251c\u2500\u2500 services \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 favorites.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 monitoring.py \u2502 \u251c\u2500\u2500 openl3.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 uploaded.py \u2502 \u251c\u2500\u2500 site \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 test_auth.py \u251c\u2500\u2500 test_files.py \u251c\u2500\u2500 test_milvus.py \u2514\u2500\u2500 test_minio.py MkDocs Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"MegaPi"},{"location":"#megapi","text":"Welcome to MegaPi, the dynamic backend API powering the music sim web application. Engineered to revolutionize the way users explore music, MegaPi delivers personalized song recommendations with unparalleled accuracy. At its core, MegaPi harnesses the power of the Milvus vector database and sophisticated single feature vectors, crafted using an Essentia CNN specifically trained for music genre classification. Coupled with the robust MinIO object storage system, MegaPi provides a seamless and innovative solution for navigating through an extensive music library, ensuring every user experience is both unique and engaging.","title":"MegaPi"},{"location":"#runs-in-a-docker-container","text":"docker compose up -d docker ps --format 'table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Status}}\\t{{.Names}}' NAMES PORTS megapi-megapi-1 8000:8000 megapi-minio-1 9000:9001 megapi-postgre-1 5432:5432","title":"Runs in a Docker container"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. . \u251c\u2500\u2500 app.py \u251c\u2500\u2500 docker-compose.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 core \u2502 \u251c\u2500\u2500 data \u2502 \u2502 \u251c\u2500\u2500 mtg_jamendo_genre.json \u2502 \u2502 \u2514\u2500\u2500 music.db \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 database.py \u2502 \u251c\u2500\u2500 extract_openl3_embeddings.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 extract_openl3_embeddings.py \u2502 \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 endpoints \u2502 \u251c\u2500\u2500 index.md \u2502 \u2514\u2500\u2500 services \u2502 \u251c\u2500\u2500 gui \u2502 \u2514\u2500\u2500 templates \u2502 \u2514\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 favorites.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u251c\u2500\u2500 openl3.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u251c\u2500\u2500 uploaded.py \u2502 \u2514\u2500\u2500 users.py \u2502 \u251c\u2500\u2500 routes \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 favorites.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 monitoring.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u251c\u2500\u2500 openl3.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 uploaded.py \u2502 \u251c\u2500\u2500 services \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 favorites.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 monitoring.py \u2502 \u251c\u2500\u2500 openl3.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 uploaded.py \u2502 \u251c\u2500\u2500 site \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 test_auth.py \u251c\u2500\u2500 test_files.py \u251c\u2500\u2500 test_milvus.py \u2514\u2500\u2500 test_minio.py","title":"Project layout"},{"location":"#mkdocs-commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"MkDocs Commands"},{"location":"endpoints/auth/","text":"Documentation for endpoints/auth.py This module contains the endpoints for the authentication service. It provides routes for user registration, login, and logout and other related operations. delete_user ( user_id , current_user = Depends ( login_manager ), db = Depends ( get_db )) Delete a user by their user ID. user_id : int - The ID of the user to delete. current_user : User - The current authenticated user attempting the deletion. db : Session - The database session dependency. return : Returns a dictionary with a detail message on successful deletion. Source code in routes/auth.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @router . delete ( \"/users/ {user_id} \" , tags = [ \"users\" ], response_model = dict ) def delete_user ( user_id : int , current_user = Depends ( login_manager ), db : Session = Depends ( get_db ) ): \"\"\" Delete a user by their user ID. - **user_id**: int - The ID of the user to delete. - **current_user**: User - The current authenticated user attempting the deletion. - **db**: Session - The database session dependency. - **return**: Returns a dictionary with a detail message on successful deletion. \"\"\" if not current_user : raise InvalidCredentialsException ( detail = \"Invalid credentials\" ) if current_user . id != 1 : raise HTTPException ( status_code = 401 , detail = \"Unauthorized\" ) user = db . query ( User ) . filter ( User . id == user_id ) . first () if not user : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) db . delete ( user ) db . commit () return { \"detail\" : \"User deleted\" } index () Render a front-end GUI for testing signup/login functionality. return : Returns an HTMLResponse containing the content of the index.html page. Source code in routes/auth.py 53 54 55 56 57 58 59 60 61 62 @router . get ( \"/gui\" , tags = [ \"auth gui\" ], response_class = HTMLResponse ) def index (): \"\"\" Render a front-end GUI for testing signup/login functionality. - **return**: Returns an HTMLResponse containing the content of the index.html page. \"\"\" file_path = os . path . join ( \"gui\" , \"templates\" , \"index.html\" ) with open ( file_path , \"r\" ) as f : return HTMLResponse ( content = f . read ()) list_users ( user = Depends ( login_manager ), db = Depends ( get_db )) List all users. user : User - The current authenticated user (unused in this function). db : Session - The database session dependency. return : Returns a list of dictionaries, each representing a user with their id and email. Source code in routes/auth.py 122 123 124 125 126 127 128 129 130 131 132 133 @router . get ( \"/users\" , tags = [ \"users\" ], response_model = list ) def list_users ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" List all users. - **user**: User - The current authenticated user (unused in this function). - **db**: Session - The database session dependency. - **return**: Returns a list of dictionaries, each representing a user with their id and email. \"\"\" users = db . query ( User ) . all () users = [{ \"id\" : user . id , \"email\" : user . email } for user in users ] return users login ( data = Depends ()) Authenticate a user and return an access token. data : OAuth2PasswordRequestForm - A form data model including username (email) and password. return : Returns a TokenData object containing the access token and token type. Source code in routes/auth.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @router . post ( \"/token\" , tags = [ \"users\" ], response_model = TokenData ) def login ( data : OAuth2PasswordRequestForm = Depends ()): \"\"\" Authenticate a user and return an access token. - **data**: OAuth2PasswordRequestForm - A form data model including username (email) and password. - **return**: Returns a TokenData object containing the access token and token type. \"\"\" email = data . username password = data . password user = get_user ( email ) if not user or not bcrypt . checkpw ( password . encode ( \"utf-8\" ), user . hashed_password . encode ( \"utf-8\" ) ): raise InvalidCredentialsException access_token_expires = timedelta ( minutes = DEFAULT_SETTINGS . access_token_expire_minutes ) access_token = login_manager . create_access_token ( data = dict ( sub = email ), expires = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" } private_route ( user = Depends ( login_manager )) A private route that requires authentication. user : User - The current authenticated user. return : Returns a dictionary with a welcome message for the authenticated user. Source code in routes/auth.py 111 112 113 114 115 116 117 118 119 @router . get ( \"/private\" , tags = [ \"users\" ], summary = \"A private route that requires authentication.\" , response_model = dict ) def private_route ( user = Depends ( login_manager )): \"\"\" A private route that requires authentication. - **user**: User - The current authenticated user. - **return**: Returns a dictionary with a welcome message for the authenticated user. \"\"\" return { \"detail\" : f \"Welcome { user . email } , you are authenticated\" } read_users_me ( user = Depends ( login_manager )) async Get the current authenticated user. user : User - The current authenticated user from the session. return : Returns the user object of the currently authenticated user. Source code in routes/auth.py 21 22 23 24 25 26 27 28 29 @router . get ( \"/users/me\" , tags = [ \"users\" ], response_model = User ) async def read_users_me ( user : User = Depends ( login_manager )): \"\"\" Get the current authenticated user. - **user**: User - The current authenticated user from the session. - **return**: Returns the user object of the currently authenticated user. \"\"\" return user register ( user , db = Depends ( get_db )) Register a new user with the provided email and password. user : UserCreate - A user creation object containing the email and password. db : Session - The database session dependency. return : Returns a dictionary with a detail message on successful registration. Source code in routes/auth.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @router . post ( \"/register\" , tags = [ \"users\" ], response_model = dict ) def register ( user : UserCreate , db : Session = Depends ( get_db )): \"\"\" Register a new user with the provided email and password. - **user**: UserCreate - A user creation object containing the email and password. - **db**: Session - The database session dependency. - **return**: Returns a dictionary with a detail message on successful registration. \"\"\" db_user = get_user ( user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"A user with this email already exists\" ) hashed_password = hash_password ( user . password ) db_user = User ( email = user . email , hashed_password = hashed_password ) db . add ( db_user ) db . commit () return { \"detail\" : \"Successfully registered\" }","title":"Auth"},{"location":"endpoints/auth/#documentation-for-endpointsauthpy","text":"This module contains the endpoints for the authentication service. It provides routes for user registration, login, and logout and other related operations.","title":"Documentation for endpoints/auth.py"},{"location":"endpoints/auth/#routes.auth.delete_user","text":"Delete a user by their user ID. user_id : int - The ID of the user to delete. current_user : User - The current authenticated user attempting the deletion. db : Session - The database session dependency. return : Returns a dictionary with a detail message on successful deletion. Source code in routes/auth.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @router . delete ( \"/users/ {user_id} \" , tags = [ \"users\" ], response_model = dict ) def delete_user ( user_id : int , current_user = Depends ( login_manager ), db : Session = Depends ( get_db ) ): \"\"\" Delete a user by their user ID. - **user_id**: int - The ID of the user to delete. - **current_user**: User - The current authenticated user attempting the deletion. - **db**: Session - The database session dependency. - **return**: Returns a dictionary with a detail message on successful deletion. \"\"\" if not current_user : raise InvalidCredentialsException ( detail = \"Invalid credentials\" ) if current_user . id != 1 : raise HTTPException ( status_code = 401 , detail = \"Unauthorized\" ) user = db . query ( User ) . filter ( User . id == user_id ) . first () if not user : raise HTTPException ( status_code = 404 , detail = \"User not found\" ) db . delete ( user ) db . commit () return { \"detail\" : \"User deleted\" }","title":"delete_user"},{"location":"endpoints/auth/#routes.auth.index","text":"Render a front-end GUI for testing signup/login functionality. return : Returns an HTMLResponse containing the content of the index.html page. Source code in routes/auth.py 53 54 55 56 57 58 59 60 61 62 @router . get ( \"/gui\" , tags = [ \"auth gui\" ], response_class = HTMLResponse ) def index (): \"\"\" Render a front-end GUI for testing signup/login functionality. - **return**: Returns an HTMLResponse containing the content of the index.html page. \"\"\" file_path = os . path . join ( \"gui\" , \"templates\" , \"index.html\" ) with open ( file_path , \"r\" ) as f : return HTMLResponse ( content = f . read ())","title":"index"},{"location":"endpoints/auth/#routes.auth.list_users","text":"List all users. user : User - The current authenticated user (unused in this function). db : Session - The database session dependency. return : Returns a list of dictionaries, each representing a user with their id and email. Source code in routes/auth.py 122 123 124 125 126 127 128 129 130 131 132 133 @router . get ( \"/users\" , tags = [ \"users\" ], response_model = list ) def list_users ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" List all users. - **user**: User - The current authenticated user (unused in this function). - **db**: Session - The database session dependency. - **return**: Returns a list of dictionaries, each representing a user with their id and email. \"\"\" users = db . query ( User ) . all () users = [{ \"id\" : user . id , \"email\" : user . email } for user in users ] return users","title":"list_users"},{"location":"endpoints/auth/#routes.auth.login","text":"Authenticate a user and return an access token. data : OAuth2PasswordRequestForm - A form data model including username (email) and password. return : Returns a TokenData object containing the access token and token type. Source code in routes/auth.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @router . post ( \"/token\" , tags = [ \"users\" ], response_model = TokenData ) def login ( data : OAuth2PasswordRequestForm = Depends ()): \"\"\" Authenticate a user and return an access token. - **data**: OAuth2PasswordRequestForm - A form data model including username (email) and password. - **return**: Returns a TokenData object containing the access token and token type. \"\"\" email = data . username password = data . password user = get_user ( email ) if not user or not bcrypt . checkpw ( password . encode ( \"utf-8\" ), user . hashed_password . encode ( \"utf-8\" ) ): raise InvalidCredentialsException access_token_expires = timedelta ( minutes = DEFAULT_SETTINGS . access_token_expire_minutes ) access_token = login_manager . create_access_token ( data = dict ( sub = email ), expires = access_token_expires ) return { \"access_token\" : access_token , \"token_type\" : \"bearer\" }","title":"login"},{"location":"endpoints/auth/#routes.auth.private_route","text":"A private route that requires authentication. user : User - The current authenticated user. return : Returns a dictionary with a welcome message for the authenticated user. Source code in routes/auth.py 111 112 113 114 115 116 117 118 119 @router . get ( \"/private\" , tags = [ \"users\" ], summary = \"A private route that requires authentication.\" , response_model = dict ) def private_route ( user = Depends ( login_manager )): \"\"\" A private route that requires authentication. - **user**: User - The current authenticated user. - **return**: Returns a dictionary with a welcome message for the authenticated user. \"\"\" return { \"detail\" : f \"Welcome { user . email } , you are authenticated\" }","title":"private_route"},{"location":"endpoints/auth/#routes.auth.read_users_me","text":"Get the current authenticated user. user : User - The current authenticated user from the session. return : Returns the user object of the currently authenticated user. Source code in routes/auth.py 21 22 23 24 25 26 27 28 29 @router . get ( \"/users/me\" , tags = [ \"users\" ], response_model = User ) async def read_users_me ( user : User = Depends ( login_manager )): \"\"\" Get the current authenticated user. - **user**: User - The current authenticated user from the session. - **return**: Returns the user object of the currently authenticated user. \"\"\" return user","title":"read_users_me"},{"location":"endpoints/auth/#routes.auth.register","text":"Register a new user with the provided email and password. user : UserCreate - A user creation object containing the email and password. db : Session - The database session dependency. return : Returns a dictionary with a detail message on successful registration. Source code in routes/auth.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @router . post ( \"/register\" , tags = [ \"users\" ], response_model = dict ) def register ( user : UserCreate , db : Session = Depends ( get_db )): \"\"\" Register a new user with the provided email and password. - **user**: UserCreate - A user creation object containing the email and password. - **db**: Session - The database session dependency. - **return**: Returns a dictionary with a detail message on successful registration. \"\"\" db_user = get_user ( user . email ) if db_user : raise HTTPException ( status_code = 400 , detail = \"A user with this email already exists\" ) hashed_password = hash_password ( user . password ) db_user = User ( email = user . email , hashed_password = hashed_password ) db . add ( db_user ) db . commit () return { \"detail\" : \"Successfully registered\" }","title":"register"},{"location":"endpoints/favorites/","text":"Documentation for endpoints/favorites.py This module contains the endpoints for the favorites service. It provides routes for adding, removing, and listing favorite songs for a user. add_song_to_favorites ( song , user = Depends ( login_manager ), db = Depends ( get_db )) async Add a song to the authenticated user's list of favorites. song : SongPath - The path of the song to be added to favorites. user : User - The authenticated user who is adding the song to favorites. db : Session - The database session for querying and updating the database. return : Returns a message indicating the song was successfully added to favorites or if it was already in favorites. Source code in routes/favorites.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @router . post ( \"/add\" , tags = [ \"favorites\" ]) async def add_song_to_favorites ( song : SongPath , user : User = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Add a song to the authenticated user's list of favorites. - **song**: SongPath - The path of the song to be added to favorites. - **user**: User - The authenticated user who is adding the song to favorites. - **db**: Session - The database session for querying and updating the database. - **return**: Returns a message indicating the song was successfully added to favorites or if it was already in favorites. \"\"\" user = db . merge ( user ) db . refresh ( user ) if len ( user . favorites ) >= 9 : # Remove the oldest song from the favorites user . favorites . pop ( 0 ) music_id = get_song_id_by_filepath ( db , song . file_path ) if not music_id : raise HTTPException ( status_code = 404 , detail = \"Song not found\" ) music = db . query ( MusicLibrary ) . get ( music_id ) # Check if the song is already in the user's favorites if music in user . favorites : return { \"message\" : \"Song is already in favorites\" } user . favorites . append ( music ) db . commit () return { \"message\" : \"Song added to favorites\" } delete_song_from_favorites ( song , user = Depends ( login_manager ), db = Depends ( get_db )) async Remove a song from the authenticated user's list of favorites. song : SongPath - The path of the song to be removed from favorites. user : User - The authenticated user who is removing the song from favorites. db : Session - The database session for querying and updating the database. return : Returns a message indicating the song was successfully removed from favorites or if the song was not found in favorites. Source code in routes/favorites.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @router . delete ( \"/delete\" , tags = [ \"favorites\" ]) async def delete_song_from_favorites ( song : SongPath , user : User = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Remove a song from the authenticated user's list of favorites. - **song**: SongPath - The path of the song to be removed from favorites. - **user**: User - The authenticated user who is removing the song from favorites. - **db**: Session - The database session for querying and updating the database. - **return**: Returns a message indicating the song was successfully removed from favorites or if the song was not found in favorites. \"\"\" user = db . merge ( user ) db . refresh ( user ) music_id = get_song_id_by_filepath ( db , song . file_path ) if not music_id : raise HTTPException ( status_code = 404 , detail = \"Song not found\" ) music = db . query ( MusicLibrary ) . get ( music_id ) for favorite in user . favorites : if favorite . id == music . id : user . favorites . remove ( favorite ) db . commit () return { \"message\" : \"Song removed from favorites\" } raise HTTPException ( status_code = 404 , detail = \"Song not found in favorites\" ) get_favorites ( user = Depends ( login_manager ), db = Depends ( get_db )) async Retrieve the list of favorite songs for the authenticated user. user : User - The authenticated user whose favorites are to be retrieved. db : Session - The database session for querying the database. return : Returns a list of the user's favorite songs. Source code in routes/favorites.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @router . get ( \"/\" , tags = [ \"favorites\" ]) async def get_favorites ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieve the list of favorite songs for the authenticated user. - **user**: User - The authenticated user whose favorites are to be retrieved. - **db**: Session - The database session for querying the database. - **return**: Returns a list of the user's favorite songs. \"\"\" # The merge() function is used to merge a detached object back into the session. # It returns a new instance that represents the existing row in the DB. # This is necessary because the 'user' object might have been created in a different session and we want to associate it with the current session. user = db . merge ( user ) # The refresh() function is used to update the attributes of the 'user' instance with the current data in the DB. # This is necessary because the 'user' object might have stale data and we want to ensure we're working with the most recent data. db . refresh ( user ) return user . favorites","title":"Favorites"},{"location":"endpoints/favorites/#documentation-for-endpointsfavoritespy","text":"This module contains the endpoints for the favorites service. It provides routes for adding, removing, and listing favorite songs for a user.","title":"Documentation for endpoints/favorites.py"},{"location":"endpoints/favorites/#routes.favorites.add_song_to_favorites","text":"Add a song to the authenticated user's list of favorites. song : SongPath - The path of the song to be added to favorites. user : User - The authenticated user who is adding the song to favorites. db : Session - The database session for querying and updating the database. return : Returns a message indicating the song was successfully added to favorites or if it was already in favorites. Source code in routes/favorites.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @router . post ( \"/add\" , tags = [ \"favorites\" ]) async def add_song_to_favorites ( song : SongPath , user : User = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Add a song to the authenticated user's list of favorites. - **song**: SongPath - The path of the song to be added to favorites. - **user**: User - The authenticated user who is adding the song to favorites. - **db**: Session - The database session for querying and updating the database. - **return**: Returns a message indicating the song was successfully added to favorites or if it was already in favorites. \"\"\" user = db . merge ( user ) db . refresh ( user ) if len ( user . favorites ) >= 9 : # Remove the oldest song from the favorites user . favorites . pop ( 0 ) music_id = get_song_id_by_filepath ( db , song . file_path ) if not music_id : raise HTTPException ( status_code = 404 , detail = \"Song not found\" ) music = db . query ( MusicLibrary ) . get ( music_id ) # Check if the song is already in the user's favorites if music in user . favorites : return { \"message\" : \"Song is already in favorites\" } user . favorites . append ( music ) db . commit () return { \"message\" : \"Song added to favorites\" }","title":"add_song_to_favorites"},{"location":"endpoints/favorites/#routes.favorites.delete_song_from_favorites","text":"Remove a song from the authenticated user's list of favorites. song : SongPath - The path of the song to be removed from favorites. user : User - The authenticated user who is removing the song from favorites. db : Session - The database session for querying and updating the database. return : Returns a message indicating the song was successfully removed from favorites or if the song was not found in favorites. Source code in routes/favorites.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @router . delete ( \"/delete\" , tags = [ \"favorites\" ]) async def delete_song_from_favorites ( song : SongPath , user : User = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Remove a song from the authenticated user's list of favorites. - **song**: SongPath - The path of the song to be removed from favorites. - **user**: User - The authenticated user who is removing the song from favorites. - **db**: Session - The database session for querying and updating the database. - **return**: Returns a message indicating the song was successfully removed from favorites or if the song was not found in favorites. \"\"\" user = db . merge ( user ) db . refresh ( user ) music_id = get_song_id_by_filepath ( db , song . file_path ) if not music_id : raise HTTPException ( status_code = 404 , detail = \"Song not found\" ) music = db . query ( MusicLibrary ) . get ( music_id ) for favorite in user . favorites : if favorite . id == music . id : user . favorites . remove ( favorite ) db . commit () return { \"message\" : \"Song removed from favorites\" } raise HTTPException ( status_code = 404 , detail = \"Song not found in favorites\" )","title":"delete_song_from_favorites"},{"location":"endpoints/favorites/#routes.favorites.get_favorites","text":"Retrieve the list of favorite songs for the authenticated user. user : User - The authenticated user whose favorites are to be retrieved. db : Session - The database session for querying the database. return : Returns a list of the user's favorite songs. Source code in routes/favorites.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @router . get ( \"/\" , tags = [ \"favorites\" ]) async def get_favorites ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieve the list of favorite songs for the authenticated user. - **user**: User - The authenticated user whose favorites are to be retrieved. - **db**: Session - The database session for querying the database. - **return**: Returns a list of the user's favorite songs. \"\"\" # The merge() function is used to merge a detached object back into the session. # It returns a new instance that represents the existing row in the DB. # This is necessary because the 'user' object might have been created in a different session and we want to associate it with the current session. user = db . merge ( user ) # The refresh() function is used to update the attributes of the 'user' instance with the current data in the DB. # This is necessary because the 'user' object might have stale data and we want to ensure we're working with the most recent data. db . refresh ( user ) return user . favorites","title":"get_favorites"},{"location":"endpoints/lyrics/","text":"Documentation for endpoints/lyrics.py This module contains the endpoints for the lyrics service. It provides routes for searching for lyrics by song title and artist, and for retrieving lyrics using https://api.lyrics.ovh get_random_row ( user = Depends ( login_manager ), db = Depends ( get_db )) Fetches a random song from the music library along with its lyrics from the lyrics.ovh API. user : User - The authenticated user making the request. db : Session - The database session for querying the database. return : Returns a JSON object containing the song's ID, details, and lyrics. Source code in routes/lyrics.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @router . get ( \"/random-lyrics\" , tags = [ \"lyrics\" ]) def get_random_row ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches a random song from the music library along with its lyrics from the lyrics.ovh API. - **user**: User - The authenticated user making the request. - **db**: Session - The database session for querying the database. - **return**: Returns a JSON object containing the song's ID, details, and lyrics. \"\"\" with db : row = db . query ( MusicLibrary ) . order_by ( func . random ()) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"No songs found in the library.\" ) lyrics = fetch_lyrics ( row . artist , row . title ) return { \"id\" : row . id , \"row\" : row , \"lyrics\" : lyrics } get_random_row_and_lyrics_and_metadata ( user = Depends ( login_manager ), db = Depends ( get_db )) Fetches a random song from the music library along with its lyrics and metadata including artwork. user : User - The authenticated user making the request. db : Session - The database session for querying the database. return : Returns a JSON object containing the song's ID, details, lyrics from the lyrics.ovh API, and artwork from the metadata. Source code in routes/lyrics.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @router . get ( \"/random-lyrics-metadata\" , tags = [ \"lyrics\" ]) def get_random_row_and_lyrics_and_metadata ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches a random song from the music library along with its lyrics and metadata including artwork. - **user**: User - The authenticated user making the request. - **db**: Session - The database session for querying the database. - **return**: Returns a JSON object containing the song's ID, details, lyrics from the lyrics.ovh API, and artwork from the metadata. \"\"\" with db : row = db . query ( MusicLibrary ) . order_by ( func . random ()) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"No songs found in the library.\" ) lyrics = fetch_lyrics ( row . artist , row . title ) artwork = get_artwork ( \"megasetbucket\" , row . filepath ) return { \"id\" : row . id , \"row\" : row , \"lyrics\" : lyrics , \"artwork\" : artwork }","title":"Lyrics"},{"location":"endpoints/lyrics/#documentation-for-endpointslyricspy","text":"This module contains the endpoints for the lyrics service. It provides routes for searching for lyrics by song title and artist, and for retrieving lyrics using https://api.lyrics.ovh","title":"Documentation for endpoints/lyrics.py"},{"location":"endpoints/lyrics/#routes.lyrics.get_random_row","text":"Fetches a random song from the music library along with its lyrics from the lyrics.ovh API. user : User - The authenticated user making the request. db : Session - The database session for querying the database. return : Returns a JSON object containing the song's ID, details, and lyrics. Source code in routes/lyrics.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @router . get ( \"/random-lyrics\" , tags = [ \"lyrics\" ]) def get_random_row ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches a random song from the music library along with its lyrics from the lyrics.ovh API. - **user**: User - The authenticated user making the request. - **db**: Session - The database session for querying the database. - **return**: Returns a JSON object containing the song's ID, details, and lyrics. \"\"\" with db : row = db . query ( MusicLibrary ) . order_by ( func . random ()) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"No songs found in the library.\" ) lyrics = fetch_lyrics ( row . artist , row . title ) return { \"id\" : row . id , \"row\" : row , \"lyrics\" : lyrics }","title":"get_random_row"},{"location":"endpoints/lyrics/#routes.lyrics.get_random_row_and_lyrics_and_metadata","text":"Fetches a random song from the music library along with its lyrics and metadata including artwork. user : User - The authenticated user making the request. db : Session - The database session for querying the database. return : Returns a JSON object containing the song's ID, details, lyrics from the lyrics.ovh API, and artwork from the metadata. Source code in routes/lyrics.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @router . get ( \"/random-lyrics-metadata\" , tags = [ \"lyrics\" ]) def get_random_row_and_lyrics_and_metadata ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches a random song from the music library along with its lyrics and metadata including artwork. - **user**: User - The authenticated user making the request. - **db**: Session - The database session for querying the database. - **return**: Returns a JSON object containing the song's ID, details, lyrics from the lyrics.ovh API, and artwork from the metadata. \"\"\" with db : row = db . query ( MusicLibrary ) . order_by ( func . random ()) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"No songs found in the library.\" ) lyrics = fetch_lyrics ( row . artist , row . title ) artwork = get_artwork ( \"megasetbucket\" , row . filepath ) return { \"id\" : row . id , \"row\" : row , \"lyrics\" : lyrics , \"artwork\" : artwork }","title":"get_random_row_and_lyrics_and_metadata"},{"location":"endpoints/milvus/","text":"Documentation for endpoints/milvus.py This module contains the endpoints for the Milvus service. It provides routes for performing queries such as similarity searches on the Milvus vector database. get_entity_by_id ( id , user = Depends ( login_manager )) Retrieves the embedding vector of a specific entity by its ID. id : str - The unique identifier of the entity. user : User - The authenticated user making the request. return : EmbeddingResponse - The embedding vector of the entity. Source code in routes/milvus.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @router . get ( \"/entity/ {id} \" , response_model = EmbeddingResponse , tags = [ \"milvus\" ]) def get_entity_by_id ( id : str , user = Depends ( login_manager )): \"\"\" Retrieves the embedding vector of a specific entity by its ID. - **id**: str - The unique identifier of the entity. - **user**: User - The authenticated user making the request. - **return**: EmbeddingResponse - The embedding vector of the entity. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"id in [ { id } ]\" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embedding = [ float ( x ) for x in entities [ 0 ][ \"embedding\" ]] return EmbeddingResponse ( id = id , embedding = embedding ) get_genres_plot ( query , user = Depends ( login_manager )) async Generates a plot of the top 5 genres for a given entity based on its file path. query : SongPath - The query containing the file path of the entity. user : User - The authenticated user making the request. return : A base64 encoded string of the plot image. Source code in routes/milvus.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @router . post ( \"/plot_genres\" , tags = [ \"milvus\" ]) async def get_genres_plot ( query : SongPath , user = Depends ( login_manager )): \"\"\" Generates a plot of the top 5 genres for a given entity based on its file path. - **query**: SongPath - The query containing the file path of the entity. - **user**: User - The authenticated user making the request. - **return**: A base64 encoded string of the plot image. \"\"\" collection_87 = get_milvus_87_collection () entity = collection_87 . query ( expr = f \"path == ' { query . file_path } '\" , output_fields = [ \"predictions\" , \"title\" , \"artist\" ], limit = 1 ) if not entity : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) class_names , top_5_activations , title , artist = await extract_plot_data ( entity ) fig = await create_plot ( class_names , top_5_activations , title , artist ) image_base64 = await convert_plot_to_base64 ( fig ) return Response ( content = image_base64 , media_type = \"text/plain\" ) get_similar_9_entities_by_path ( query , user = Depends ( login_manager )) Retrieves the 9 most similar entities (by title, artist, album) based on the file path of an entity. query : FilePathsQuery - The query containing the file path(s) of the entity. user : User - The authenticated user making the request. return : A list of the 9 most similar entities with short details. Source code in routes/milvus.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 @router . post ( \"/similar_short_entity\" , tags = [ \"milvus\" ], response_model = SimilarShortEntitiesResponse ) def get_similar_9_entities_by_path ( query : FilePathsQuery , user = Depends ( login_manager )): \"\"\" Retrieves the 9 most similar entities (by title, artist, album) based on the file path of an entity. - **query**: FilePathsQuery - The query containing the file path(s) of the entity. - **user**: User - The authenticated user making the request. - **return**: A list of the 9 most similar entities with short details. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"path in { query . path } \" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embeddings = [[ float ( x ) for x in entity [ \"embedding\" ]] for entity in entities ] entities = collection_512 . search ( data = embeddings , anns_field = \"embedding\" , param = { \"nprobe\" : 16 }, limit = 30 , offset = 1 , output_fields = [ \"title\" , \"album\" , \"artist\" , \"path\" ], ) sorted_entities = sort_entities ( entities ) return { \"entities\" : sorted_entities } get_similar_entities ( id , user = Depends ( login_manager )) Retrieves the top 3 most similar entities to a given entity ID. id : str - The unique identifier of the entity to compare. user : User - The authenticated user making the request. return : SimilarFullEntitiesResponse - A list of the most similar entities. Source code in routes/milvus.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @router . get ( \"/similar/ {id} \" , tags = [ \"milvus\" ], response_model = SimilarFullEntitiesResponse ) def get_similar_entities ( id : str , user = Depends ( login_manager )): \"\"\" Retrieves the top 3 most similar entities to a given entity ID. - **id**: str - The unique identifier of the entity to compare. - **user**: User - The authenticated user making the request. - **return**: SimilarFullEntitiesResponse - A list of the most similar entities. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"id in [ { id } ]\" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embedding = [ float ( x ) for x in entities [ 0 ][ \"embedding\" ]] entities = collection_512 . search ( data = [ embedding ], anns_field = \"embedding\" , param = { \"nprobe\" : 16 }, limit = 3 , offset = 1 , output_fields = [ \"*\" ], ) response_list = [ full_hit_to_dict ( hit ) for hit in entities [ 0 ]] return SimilarFullEntitiesResponse ( hits = response_list ) get_similar_entities_by_path ( query , user = Depends ( login_manager )) Retrieves the top 3 most similar entities based on the file path of an entity. query : FilePathsQuery - The query containing the file path(s) of the entity. user : User - The authenticated user making the request. return : SimilarFullEntitiesResponse - A list of the most similar entities with full details. Source code in routes/milvus.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @router . post ( \"/similar_full_entity\" , tags = [ \"milvus\" ], response_model = SimilarFullEntitiesResponse ) def get_similar_entities_by_path ( query : FilePathsQuery , user = Depends ( login_manager )): \"\"\" Retrieves the top 3 most similar entities based on the file path of an entity. - **query**: FilePathsQuery - The query containing the file path(s) of the entity. - **user**: User - The authenticated user making the request. - **return**: SimilarFullEntitiesResponse - A list of the most similar entities with full details. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"path in { query . path } \" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embeddings = [[ float ( x ) for x in entity [ \"embedding\" ]] for entity in entities ] entities = collection_512 . search ( data = embeddings , anns_field = \"embedding\" , param = { \"nprobe\" : 16 }, limit = 3 , offset = 1 , output_fields = [ \"*\" ], ) response_list = [ short_hit_to_dict ( hit ) for hit in entities [ 0 ]] return SimilarFullEntitiesResponse ( hits = response_list ) ping_milvus_collection () Checks the connectivity with the Milvus vector database. Mostly used to make prometheus ping milvus everyday, so milvus doesn't get idle for 7 days and shutdown. return : The status of the Milvus service. Source code in routes/milvus.py 155 156 157 158 159 160 161 162 163 @router . get ( \"/ping\" , tags = [ \"milvus\" ]) def ping_milvus_collection (): \"\"\" Checks the connectivity with the Milvus vector database. Mostly used to make prometheus ping milvus everyday, so milvus doesn't get idle for 7 days and shutdown. - **return**: The status of the Milvus service. \"\"\" milvus_status = ping_milvus () return milvus_status","title":"Milvus"},{"location":"endpoints/milvus/#documentation-for-endpointsmilvuspy","text":"This module contains the endpoints for the Milvus service. It provides routes for performing queries such as similarity searches on the Milvus vector database.","title":"Documentation for endpoints/milvus.py"},{"location":"endpoints/milvus/#routes.milvus.get_entity_by_id","text":"Retrieves the embedding vector of a specific entity by its ID. id : str - The unique identifier of the entity. user : User - The authenticated user making the request. return : EmbeddingResponse - The embedding vector of the entity. Source code in routes/milvus.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @router . get ( \"/entity/ {id} \" , response_model = EmbeddingResponse , tags = [ \"milvus\" ]) def get_entity_by_id ( id : str , user = Depends ( login_manager )): \"\"\" Retrieves the embedding vector of a specific entity by its ID. - **id**: str - The unique identifier of the entity. - **user**: User - The authenticated user making the request. - **return**: EmbeddingResponse - The embedding vector of the entity. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"id in [ { id } ]\" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embedding = [ float ( x ) for x in entities [ 0 ][ \"embedding\" ]] return EmbeddingResponse ( id = id , embedding = embedding )","title":"get_entity_by_id"},{"location":"endpoints/milvus/#routes.milvus.get_genres_plot","text":"Generates a plot of the top 5 genres for a given entity based on its file path. query : SongPath - The query containing the file path of the entity. user : User - The authenticated user making the request. return : A base64 encoded string of the plot image. Source code in routes/milvus.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 @router . post ( \"/plot_genres\" , tags = [ \"milvus\" ]) async def get_genres_plot ( query : SongPath , user = Depends ( login_manager )): \"\"\" Generates a plot of the top 5 genres for a given entity based on its file path. - **query**: SongPath - The query containing the file path of the entity. - **user**: User - The authenticated user making the request. - **return**: A base64 encoded string of the plot image. \"\"\" collection_87 = get_milvus_87_collection () entity = collection_87 . query ( expr = f \"path == ' { query . file_path } '\" , output_fields = [ \"predictions\" , \"title\" , \"artist\" ], limit = 1 ) if not entity : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) class_names , top_5_activations , title , artist = await extract_plot_data ( entity ) fig = await create_plot ( class_names , top_5_activations , title , artist ) image_base64 = await convert_plot_to_base64 ( fig ) return Response ( content = image_base64 , media_type = \"text/plain\" )","title":"get_genres_plot"},{"location":"endpoints/milvus/#routes.milvus.get_similar_9_entities_by_path","text":"Retrieves the 9 most similar entities (by title, artist, album) based on the file path of an entity. query : FilePathsQuery - The query containing the file path(s) of the entity. user : User - The authenticated user making the request. return : A list of the 9 most similar entities with short details. Source code in routes/milvus.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 @router . post ( \"/similar_short_entity\" , tags = [ \"milvus\" ], response_model = SimilarShortEntitiesResponse ) def get_similar_9_entities_by_path ( query : FilePathsQuery , user = Depends ( login_manager )): \"\"\" Retrieves the 9 most similar entities (by title, artist, album) based on the file path of an entity. - **query**: FilePathsQuery - The query containing the file path(s) of the entity. - **user**: User - The authenticated user making the request. - **return**: A list of the 9 most similar entities with short details. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"path in { query . path } \" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embeddings = [[ float ( x ) for x in entity [ \"embedding\" ]] for entity in entities ] entities = collection_512 . search ( data = embeddings , anns_field = \"embedding\" , param = { \"nprobe\" : 16 }, limit = 30 , offset = 1 , output_fields = [ \"title\" , \"album\" , \"artist\" , \"path\" ], ) sorted_entities = sort_entities ( entities ) return { \"entities\" : sorted_entities }","title":"get_similar_9_entities_by_path"},{"location":"endpoints/milvus/#routes.milvus.get_similar_entities","text":"Retrieves the top 3 most similar entities to a given entity ID. id : str - The unique identifier of the entity to compare. user : User - The authenticated user making the request. return : SimilarFullEntitiesResponse - A list of the most similar entities. Source code in routes/milvus.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @router . get ( \"/similar/ {id} \" , tags = [ \"milvus\" ], response_model = SimilarFullEntitiesResponse ) def get_similar_entities ( id : str , user = Depends ( login_manager )): \"\"\" Retrieves the top 3 most similar entities to a given entity ID. - **id**: str - The unique identifier of the entity to compare. - **user**: User - The authenticated user making the request. - **return**: SimilarFullEntitiesResponse - A list of the most similar entities. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"id in [ { id } ]\" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embedding = [ float ( x ) for x in entities [ 0 ][ \"embedding\" ]] entities = collection_512 . search ( data = [ embedding ], anns_field = \"embedding\" , param = { \"nprobe\" : 16 }, limit = 3 , offset = 1 , output_fields = [ \"*\" ], ) response_list = [ full_hit_to_dict ( hit ) for hit in entities [ 0 ]] return SimilarFullEntitiesResponse ( hits = response_list )","title":"get_similar_entities"},{"location":"endpoints/milvus/#routes.milvus.get_similar_entities_by_path","text":"Retrieves the top 3 most similar entities based on the file path of an entity. query : FilePathsQuery - The query containing the file path(s) of the entity. user : User - The authenticated user making the request. return : SimilarFullEntitiesResponse - A list of the most similar entities with full details. Source code in routes/milvus.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @router . post ( \"/similar_full_entity\" , tags = [ \"milvus\" ], response_model = SimilarFullEntitiesResponse ) def get_similar_entities_by_path ( query : FilePathsQuery , user = Depends ( login_manager )): \"\"\" Retrieves the top 3 most similar entities based on the file path of an entity. - **query**: FilePathsQuery - The query containing the file path(s) of the entity. - **user**: User - The authenticated user making the request. - **return**: SimilarFullEntitiesResponse - A list of the most similar entities with full details. \"\"\" collection_512 = get_milvus_512_collection () entities = collection_512 . query ( expr = f \"path in { query . path } \" , output_fields = [ \"embedding\" ]) if not entities : raise HTTPException ( status_code = 404 , detail = \"Entity not found\" ) embeddings = [[ float ( x ) for x in entity [ \"embedding\" ]] for entity in entities ] entities = collection_512 . search ( data = embeddings , anns_field = \"embedding\" , param = { \"nprobe\" : 16 }, limit = 3 , offset = 1 , output_fields = [ \"*\" ], ) response_list = [ short_hit_to_dict ( hit ) for hit in entities [ 0 ]] return SimilarFullEntitiesResponse ( hits = response_list )","title":"get_similar_entities_by_path"},{"location":"endpoints/milvus/#routes.milvus.ping_milvus_collection","text":"Checks the connectivity with the Milvus vector database. Mostly used to make prometheus ping milvus everyday, so milvus doesn't get idle for 7 days and shutdown. return : The status of the Milvus service. Source code in routes/milvus.py 155 156 157 158 159 160 161 162 163 @router . get ( \"/ping\" , tags = [ \"milvus\" ]) def ping_milvus_collection (): \"\"\" Checks the connectivity with the Milvus vector database. Mostly used to make prometheus ping milvus everyday, so milvus doesn't get idle for 7 days and shutdown. - **return**: The status of the Milvus service. \"\"\" milvus_status = ping_milvus () return milvus_status","title":"ping_milvus_collection"},{"location":"endpoints/minio/","text":"Documentation for endpoints/minio.py This module contains the endpoints for the MiniO service. It provides endpoints for storing and retriveing objects from MiniO buckets. download_file ( query , user = Depends ( login_manager )) async Downloads a song file from MinIO storage. query : SongPath - The path to the song file in MinIO storage. user : User - The authenticated user making the request. return : StreamingResponse - A streaming response for downloading the song file. Source code in routes/minio.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @router . post ( \"/download-song/\" , tags = [ \"MinIO\" ]) async def download_file ( query : SongPath , user = Depends ( login_manager )): \"\"\" Downloads a song file from MinIO storage. - **query**: SongPath - The path to the song file in MinIO storage. - **user**: User - The authenticated user making the request. - **return**: StreamingResponse - A streaming response for downloading the song file. \"\"\" try : data = minio_client . get_object ( DEFAULT_SETTINGS . minio_bucket_name , query . file_path ) filename = query . file_path . split ( '/' )[ - 1 ] # Get the filename from the file_path headers = { \"Content-Disposition\" : f \"attachment; filename= { filename } \" , } return StreamingResponse ( data . stream ( 32 * 1024 ), media_type = \"audio/mpeg\" , headers = headers ) except Exception as e : raise HTTPException ( status_code = 404 , detail = \"File not found\" ) get_file ( query , user = Depends ( login_manager )) async Streams a song file from MinIO storage. query : SongPath - The path to the song file in MinIO storage. user : User - The authenticated user making the request. return : StreamingResponse - A streaming response of the song file. Source code in routes/minio.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @router . post ( \"/stream-song/\" , tags = [ \"MinIO\" ]) async def get_file ( query : SongPath , user = Depends ( login_manager )): \"\"\" Streams a song file from MinIO storage. - **query**: SongPath - The path to the song file in MinIO storage. - **user**: User - The authenticated user making the request. - **return**: StreamingResponse - A streaming response of the song file. \"\"\" try : data = minio_client . get_object ( DEFAULT_SETTINGS . minio_bucket_name , query . file_path ) return StreamingResponse ( data . stream ( 32 * 1024 ), media_type = \"audio/mpeg\" ) except Exception as e : raise HTTPException ( status_code = 404 , detail = \"File not found\" ) get_random_song_metadata ( user = Depends ( login_manager ), db = Depends ( get_db )) async Retrieves metadata for a random song from MinIO storage using the music-tag library. user : User - The authenticated user making the request. db : Session - Database session dependency. return : JSONResponse - The metadata of a random song. Source code in routes/minio.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @router . get ( \"/random-metadata\" , tags = [ \"MinIO\" ]) async def get_random_song_metadata ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieves metadata for a random song from MinIO storage using the music-tag library. - **user**: User - The authenticated user making the request. - **db**: Session - Database session dependency. - **return**: JSONResponse - The metadata of a random song. \"\"\" try : count = db . query ( MusicLibrary ) . count () random_id = randint ( 1 , count ) row = db . query ( MusicLibrary ) . filter ( MusicLibrary . id == random_id ) . first () metadata = get_metadata_and_artwork ( DEFAULT_SETTINGS . minio_bucket_name , row . filepath ) return JSONResponse ( content = metadata ) except Exception as e : raise HTTPException ( status_code = 400 , detail = str ( e )) finally : db . close () get_song_metadata ( query , user = Depends ( login_manager )) async Retrieves metadata for a specified song from MinIO storage using the music-tag library. query : SongPath - The path to the song file in MinIO storage. user : User - The authenticated user making the request. return : JSONResponse - The metadata of the specified song. Source code in routes/minio.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @router . post ( \"/metadata\" , tags = [ \"MinIO\" ]) async def get_song_metadata ( query : SongPath , user = Depends ( login_manager )): \"\"\" Retrieves metadata for a specified song from MinIO storage using the music-tag library. - **query**: SongPath - The path to the song file in MinIO storage. - **user**: User - The authenticated user making the request. - **return**: JSONResponse - The metadata of the specified song. \"\"\" try : metadata = get_metadata_and_artwork ( DEFAULT_SETTINGS . minio_bucket_name , query . file_path ) return JSONResponse ( content = metadata ) except Exception as e : raise HTTPException ( status_code = 400 , detail = str ( e )) list_objects_in_album_folder ( query , user = Depends ( login_manager )) Retrieves a list of objects within a specified album folder in the MinIO bucket. query : AlbumResponse - The album folder to list objects from. user : User - The authenticated user making the request. return : List[S3Object] - A list of objects found in the specified album folder. Source code in routes/minio.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @router . post ( \"/list-objects/\" , response_model = List [ S3Object ], tags = [ \"MinIO\" ]) def list_objects_in_album_folder ( query : AlbumResponse , user = Depends ( login_manager )): \"\"\" Retrieves a list of objects within a specified album folder in the MinIO bucket. - **query**: AlbumResponse - The album folder to list objects from. - **user**: User - The authenticated user making the request. - **return**: List[S3Object] - A list of objects found in the specified album folder. \"\"\" objects = minio_client . list_objects ( DEFAULT_SETTINGS . minio_bucket_name , prefix = query . album_folder , recursive = True ) response = [] for obj in objects : s3_object = { \"name\" : obj . object_name , \"size\" : obj . size , \"etag\" : obj . etag , \"last_modified\" : obj . last_modified . isoformat () } response . append ( s3_object ) return response list_uploaded_objects ( user = Depends ( login_manager ), db = Depends ( get_db )) Lists objects uploaded by the authenticated user. user : User - The authenticated user making the request. db : Session - Database session dependency. return : UploadMP3ResponseList - A list of uploaded objects by the user. Source code in routes/minio.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @router . post ( \"/list-uploaded-objects\" , response_model = UploadMP3ResponseList , tags = [ \"MinIO\" ]) def list_uploaded_objects ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists objects uploaded by the authenticated user. - **user**: User - The authenticated user making the request. - **db**: Session - Database session dependency. - **return**: UploadMP3ResponseList - A list of uploaded objects by the user. \"\"\" objects = minio_client . list_objects ( DEFAULT_SETTINGS . minio_temp_bucket_name ) # Adjusting the response to match the expected structure uploads = [ UploadDetail ( filename = obj . object_name ) for obj in objects ] response = UploadMP3ResponseList ( uploads = uploads ) return response upload_file ( file = File ( ... ), user = Depends ( login_manager ), db = Depends ( get_db )) async Uploads a MP3 file to MinIO storage using a temporary bucket. file : UploadFile - The MP3 file to upload. user : User - The authenticated user making the request. db : Session - Database session dependency. return : UploadMP3ResponseList - A list of uploaded MP3 files by the user. Source code in routes/minio.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @router . post ( \"/upload-temp\" , tags = [ \"MinIO\" ], response_model = UploadMP3ResponseList ) async def upload_file ( file : UploadFile = File ( ... ), user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Uploads a MP3 file to MinIO storage using a temporary bucket. - **file**: UploadFile - The MP3 file to upload. - **user**: User - The authenticated user making the request. - **db**: Session - Database session dependency. - **return**: UploadMP3ResponseList - A list of uploaded MP3 files by the user. \"\"\" try : # Check content type and extension if file . content_type != \"audio/mpeg\" : raise HTTPException ( status_code = 400 , detail = \"Only MP3 files are allowed.\" ) _ , file_extension = os . path . splitext ( file . filename ) if file_extension . lower () != \".mp3\" : raise HTTPException ( status_code = 400 , detail = \"The uploaded file is not an MP3 file.\" ) # Generate a secure filename secure_filename = sanitize_filename ( file . filename ) # Determine the size of the uploaded file by moving the cursor to the end to get the file size file . file . seek ( 0 , os . SEEK_END ) file_size = file . file . tell () file . file . seek ( 0 ) # Stream the file directly to MinIO minio_client . put_object ( bucket_name = DEFAULT_SETTINGS . minio_temp_bucket_name , object_name = secure_filename , data = file . file , length = file_size , content_type = file . content_type ) # Store upload information in the database and return the updated list of uploaded songs by the user # song_path_in_minio = f\"{DEFAULT_SETTINGS.minio_temp_bucket_name}/{secure_filename}\" store_upload_info ( db , user . id , secure_filename ) uploaded_songs = get_user_uploads ( db , user . id ) return UploadMP3ResponseList ( uploads = uploaded_songs ) except Exception as e : raise HTTPException ( status_code = 500 , detail = f \"An unexpected error occurred. { str ( e ) } \" )","title":"MinIO"},{"location":"endpoints/minio/#documentation-for-endpointsminiopy","text":"This module contains the endpoints for the MiniO service. It provides endpoints for storing and retriveing objects from MiniO buckets.","title":"Documentation for endpoints/minio.py"},{"location":"endpoints/minio/#routes.minio.download_file","text":"Downloads a song file from MinIO storage. query : SongPath - The path to the song file in MinIO storage. user : User - The authenticated user making the request. return : StreamingResponse - A streaming response for downloading the song file. Source code in routes/minio.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @router . post ( \"/download-song/\" , tags = [ \"MinIO\" ]) async def download_file ( query : SongPath , user = Depends ( login_manager )): \"\"\" Downloads a song file from MinIO storage. - **query**: SongPath - The path to the song file in MinIO storage. - **user**: User - The authenticated user making the request. - **return**: StreamingResponse - A streaming response for downloading the song file. \"\"\" try : data = minio_client . get_object ( DEFAULT_SETTINGS . minio_bucket_name , query . file_path ) filename = query . file_path . split ( '/' )[ - 1 ] # Get the filename from the file_path headers = { \"Content-Disposition\" : f \"attachment; filename= { filename } \" , } return StreamingResponse ( data . stream ( 32 * 1024 ), media_type = \"audio/mpeg\" , headers = headers ) except Exception as e : raise HTTPException ( status_code = 404 , detail = \"File not found\" )","title":"download_file"},{"location":"endpoints/minio/#routes.minio.get_file","text":"Streams a song file from MinIO storage. query : SongPath - The path to the song file in MinIO storage. user : User - The authenticated user making the request. return : StreamingResponse - A streaming response of the song file. Source code in routes/minio.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @router . post ( \"/stream-song/\" , tags = [ \"MinIO\" ]) async def get_file ( query : SongPath , user = Depends ( login_manager )): \"\"\" Streams a song file from MinIO storage. - **query**: SongPath - The path to the song file in MinIO storage. - **user**: User - The authenticated user making the request. - **return**: StreamingResponse - A streaming response of the song file. \"\"\" try : data = minio_client . get_object ( DEFAULT_SETTINGS . minio_bucket_name , query . file_path ) return StreamingResponse ( data . stream ( 32 * 1024 ), media_type = \"audio/mpeg\" ) except Exception as e : raise HTTPException ( status_code = 404 , detail = \"File not found\" )","title":"get_file"},{"location":"endpoints/minio/#routes.minio.get_random_song_metadata","text":"Retrieves metadata for a random song from MinIO storage using the music-tag library. user : User - The authenticated user making the request. db : Session - Database session dependency. return : JSONResponse - The metadata of a random song. Source code in routes/minio.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @router . get ( \"/random-metadata\" , tags = [ \"MinIO\" ]) async def get_random_song_metadata ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieves metadata for a random song from MinIO storage using the music-tag library. - **user**: User - The authenticated user making the request. - **db**: Session - Database session dependency. - **return**: JSONResponse - The metadata of a random song. \"\"\" try : count = db . query ( MusicLibrary ) . count () random_id = randint ( 1 , count ) row = db . query ( MusicLibrary ) . filter ( MusicLibrary . id == random_id ) . first () metadata = get_metadata_and_artwork ( DEFAULT_SETTINGS . minio_bucket_name , row . filepath ) return JSONResponse ( content = metadata ) except Exception as e : raise HTTPException ( status_code = 400 , detail = str ( e )) finally : db . close ()","title":"get_random_song_metadata"},{"location":"endpoints/minio/#routes.minio.get_song_metadata","text":"Retrieves metadata for a specified song from MinIO storage using the music-tag library. query : SongPath - The path to the song file in MinIO storage. user : User - The authenticated user making the request. return : JSONResponse - The metadata of the specified song. Source code in routes/minio.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @router . post ( \"/metadata\" , tags = [ \"MinIO\" ]) async def get_song_metadata ( query : SongPath , user = Depends ( login_manager )): \"\"\" Retrieves metadata for a specified song from MinIO storage using the music-tag library. - **query**: SongPath - The path to the song file in MinIO storage. - **user**: User - The authenticated user making the request. - **return**: JSONResponse - The metadata of the specified song. \"\"\" try : metadata = get_metadata_and_artwork ( DEFAULT_SETTINGS . minio_bucket_name , query . file_path ) return JSONResponse ( content = metadata ) except Exception as e : raise HTTPException ( status_code = 400 , detail = str ( e ))","title":"get_song_metadata"},{"location":"endpoints/minio/#routes.minio.list_objects_in_album_folder","text":"Retrieves a list of objects within a specified album folder in the MinIO bucket. query : AlbumResponse - The album folder to list objects from. user : User - The authenticated user making the request. return : List[S3Object] - A list of objects found in the specified album folder. Source code in routes/minio.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @router . post ( \"/list-objects/\" , response_model = List [ S3Object ], tags = [ \"MinIO\" ]) def list_objects_in_album_folder ( query : AlbumResponse , user = Depends ( login_manager )): \"\"\" Retrieves a list of objects within a specified album folder in the MinIO bucket. - **query**: AlbumResponse - The album folder to list objects from. - **user**: User - The authenticated user making the request. - **return**: List[S3Object] - A list of objects found in the specified album folder. \"\"\" objects = minio_client . list_objects ( DEFAULT_SETTINGS . minio_bucket_name , prefix = query . album_folder , recursive = True ) response = [] for obj in objects : s3_object = { \"name\" : obj . object_name , \"size\" : obj . size , \"etag\" : obj . etag , \"last_modified\" : obj . last_modified . isoformat () } response . append ( s3_object ) return response","title":"list_objects_in_album_folder"},{"location":"endpoints/minio/#routes.minio.list_uploaded_objects","text":"Lists objects uploaded by the authenticated user. user : User - The authenticated user making the request. db : Session - Database session dependency. return : UploadMP3ResponseList - A list of uploaded objects by the user. Source code in routes/minio.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @router . post ( \"/list-uploaded-objects\" , response_model = UploadMP3ResponseList , tags = [ \"MinIO\" ]) def list_uploaded_objects ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists objects uploaded by the authenticated user. - **user**: User - The authenticated user making the request. - **db**: Session - Database session dependency. - **return**: UploadMP3ResponseList - A list of uploaded objects by the user. \"\"\" objects = minio_client . list_objects ( DEFAULT_SETTINGS . minio_temp_bucket_name ) # Adjusting the response to match the expected structure uploads = [ UploadDetail ( filename = obj . object_name ) for obj in objects ] response = UploadMP3ResponseList ( uploads = uploads ) return response","title":"list_uploaded_objects"},{"location":"endpoints/minio/#routes.minio.upload_file","text":"Uploads a MP3 file to MinIO storage using a temporary bucket. file : UploadFile - The MP3 file to upload. user : User - The authenticated user making the request. db : Session - Database session dependency. return : UploadMP3ResponseList - A list of uploaded MP3 files by the user. Source code in routes/minio.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @router . post ( \"/upload-temp\" , tags = [ \"MinIO\" ], response_model = UploadMP3ResponseList ) async def upload_file ( file : UploadFile = File ( ... ), user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Uploads a MP3 file to MinIO storage using a temporary bucket. - **file**: UploadFile - The MP3 file to upload. - **user**: User - The authenticated user making the request. - **db**: Session - Database session dependency. - **return**: UploadMP3ResponseList - A list of uploaded MP3 files by the user. \"\"\" try : # Check content type and extension if file . content_type != \"audio/mpeg\" : raise HTTPException ( status_code = 400 , detail = \"Only MP3 files are allowed.\" ) _ , file_extension = os . path . splitext ( file . filename ) if file_extension . lower () != \".mp3\" : raise HTTPException ( status_code = 400 , detail = \"The uploaded file is not an MP3 file.\" ) # Generate a secure filename secure_filename = sanitize_filename ( file . filename ) # Determine the size of the uploaded file by moving the cursor to the end to get the file size file . file . seek ( 0 , os . SEEK_END ) file_size = file . file . tell () file . file . seek ( 0 ) # Stream the file directly to MinIO minio_client . put_object ( bucket_name = DEFAULT_SETTINGS . minio_temp_bucket_name , object_name = secure_filename , data = file . file , length = file_size , content_type = file . content_type ) # Store upload information in the database and return the updated list of uploaded songs by the user # song_path_in_minio = f\"{DEFAULT_SETTINGS.minio_temp_bucket_name}/{secure_filename}\" store_upload_info ( db , user . id , secure_filename ) uploaded_songs = get_user_uploads ( db , user . id ) return UploadMP3ResponseList ( uploads = uploaded_songs ) except Exception as e : raise HTTPException ( status_code = 500 , detail = f \"An unexpected error occurred. { str ( e ) } \" )","title":"upload_file"},{"location":"endpoints/monitoring/","text":"Documentation for endpoints/monitoring.py This module contains endpoint to retrives various system statistics on a Linux machine, including CPU temperature, CPU usage, memory usage, and disk usage. get_all_pi ( user = Depends ( login_manager )) async Retrieves comprehensive monitoring statistics for a Linux host machine. These statistics include CPU usage, memory usage, disk space, temperature readings. user : User - The authenticated user making the request, verified through the login_manager . return : A JSON response containing the linux host's monitoring statistics. Source code in routes/monitoring.py 9 10 11 12 13 14 15 16 17 18 19 @router . get ( \"/pi\" , tags = [ \"monitoring\" ]) async def get_all_pi ( user = Depends ( login_manager )): \"\"\" Retrieves comprehensive monitoring statistics for a Linux host machine. These statistics include CPU usage, memory usage, disk space, temperature readings. - **user**: User - The authenticated user making the request, verified through the `login_manager`. - **return**: A JSON response containing the linux host's monitoring statistics. \"\"\" return get_all_pi_stats ()","title":"Monitoring"},{"location":"endpoints/monitoring/#documentation-for-endpointsmonitoringpy","text":"This module contains endpoint to retrives various system statistics on a Linux machine, including CPU temperature, CPU usage, memory usage, and disk usage.","title":"Documentation for endpoints/monitoring.py"},{"location":"endpoints/monitoring/#routes.monitoring.get_all_pi","text":"Retrieves comprehensive monitoring statistics for a Linux host machine. These statistics include CPU usage, memory usage, disk space, temperature readings. user : User - The authenticated user making the request, verified through the login_manager . return : A JSON response containing the linux host's monitoring statistics. Source code in routes/monitoring.py 9 10 11 12 13 14 15 16 17 18 19 @router . get ( \"/pi\" , tags = [ \"monitoring\" ]) async def get_all_pi ( user = Depends ( login_manager )): \"\"\" Retrieves comprehensive monitoring statistics for a Linux host machine. These statistics include CPU usage, memory usage, disk space, temperature readings. - **user**: User - The authenticated user making the request, verified through the `login_manager`. - **return**: A JSON response containing the linux host's monitoring statistics. \"\"\" return get_all_pi_stats ()","title":"get_all_pi"},{"location":"endpoints/music/","text":"Documentation for endpoints/music.py This module contains the endpoints for operations on the music database. It provides routes for searching for music by song title and artist. add_row ( query , user = Depends ( login_manager ), db = Depends ( get_db )) Adds a new song to the music_library table. Parameters : query : AddSongToMusicLibrary object containing the song details to be added. user : User object, automatically provided by the login_manager dependency. Returns : A message indicating successful addition of the song. Source code in routes/music.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @router . post ( \"/add\" , tags = [ \"songs\" ]) def add_row ( query : AddSongToMusicLibrary , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Adds a new song to the music_library table. - **Parameters**: - **query**: AddSongToMusicLibrary object containing the song details to be added. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A message indicating successful addition of the song. \"\"\" try : max_id = db . query ( func . max ( MusicLibrary . id )) . scalar () # Get the maximum id from the music_library table if max_id is None : max_id = 0 # If the table is empty, set max_id to 0 # insert into the table stmt = insert ( MusicLibrary ) . values ( id = max_id + 1 , # Set the id to one more than the current maximum filename = query . filename , filepath = query . filepath , album_folder = query . album_folder , artist_folder = query . artist_folder , filesize = query . filesize , title = query . title , artist = query . artist , album = query . album , year = query . year , tracknumber = query . tracknumber , genre = query . genre , top_5_genres = query . top_5_genres , ) db . execute ( stmt ) db . commit () return { \"message\" : \"Row added successfully\" } finally : db . close () count_rows ( db = Depends ( get_db )) Returns the total number of rows in the music_library table. Parameters : None Returns : An integer representing the total number of rows in the music_library table. Source code in routes/music.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @router . get ( \"/count\" , tags = [ \"songs\" ]) def count_rows ( db : Session = Depends ( get_db )): \"\"\" Returns the total number of rows in the music_library table. - **Parameters**: None - **Returns**: An integer representing the total number of rows in the music_library table. \"\"\" try : result = db . execute ( text ( \"SELECT COUNT(*) FROM music_library\" )) count = result . scalar () return count finally : db . close () delete_row ( id , user = Depends ( login_manager ), db = Depends ( get_db )) Deletes a specific song from the music_library table by its ID. Parameters : id : Integer, the ID of the song to delete. user : User object, automatically provided by the login_manager dependency. Returns : A message indicating successful deletion of the song. Raises a 404 HTTPException if the song is not found. Source code in routes/music.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @router . delete ( \"/delete/ {id} \" , tags = [ \"songs\" ]) def delete_row ( id : int , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Deletes a specific song from the music_library table by its ID. - **Parameters**: - **id**: Integer, the ID of the song to delete. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A message indicating successful deletion of the song. Raises a 404 HTTPException if the song is not found. \"\"\" try : row = db . query ( MusicLibrary ) . get ( id ) if row is None : raise HTTPException ( status_code = 404 , detail = \"Row not found\" ) db . delete ( row ) db . commit () return { \"message\" : \"Row deleted successfully\" } finally : db . close () get_album_folder_by_artist_and_album ( query , user = Depends ( login_manager ), db = Depends ( get_db )) Retrieves the album folder for a specific artist and album combination in the music_library table. Parameters : query : ArtistAlbumResponse object containing the artist's name and album title. user : User object, automatically provided by the login_manager dependency. Returns : A dictionary containing the album folder name. Raises a 404 HTTPException if the album is not found. Source code in routes/music.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 @router . post ( \"/album_folder_by_artist_and_album\" , tags = [ \"songs\" ]) def get_album_folder_by_artist_and_album ( query : ArtistAlbumResponse , user = Depends ( login_manager ), db : Session = Depends ( get_db ) ): \"\"\" Retrieves the album folder for a specific artist and album combination in the music_library table. - **Parameters**: - **query**: ArtistAlbumResponse object containing the artist's name and album title. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A dictionary containing the album folder name. Raises a 404 HTTPException if the album is not found. \"\"\" artist = query . artist album = query . album try : row = db . query ( MusicLibrary . album_folder ) . filter ( MusicLibrary . artist == artist , MusicLibrary . album == album ) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"Album not found\" ) return { \"album_folder\" : row . album_folder } finally : db . close () get_random_row ( user = Depends ( login_manager ), db = Depends ( get_db )) Retrieves a random song from the music_library table. Parameters : user : User object, automatically provided by the login_manager dependency. Returns : A dictionary containing the ID of the randomly selected song and the song's row data. Source code in routes/music.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @router . get ( \"/random\" , tags = [ \"songs\" ]) def get_random_row ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieves a random song from the music_library table. - **Parameters**: - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A dictionary containing the ID of the randomly selected song and the song's row data. \"\"\" try : count = db . query ( MusicLibrary ) . count () random_id = randint ( 1 , count ) row = db . query ( MusicLibrary ) . filter ( MusicLibrary . id == random_id ) . first () return { \"id\" : random_id , \"row\" : row } finally : db . close () get_song_by_id ( id , user = Depends ( login_manager ), db = Depends ( get_db )) Fetches a specific song from the music_library table by its ID. Parameters : id : Integer, the ID of the song to retrieve. user : User object, automatically provided by the login_manager dependency. Returns : A dictionary containing the ID of the song and the song's row data. Raises a 404 HTTPException if the song is not found. Source code in routes/music.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @router . get ( \"/song/ {id} \" , tags = [ \"songs\" ]) def get_song_by_id ( id : int , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches a specific song from the music_library table by its ID. - **Parameters**: - **id**: Integer, the ID of the song to retrieve. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A dictionary containing the ID of the song and the song's row data. Raises a 404 HTTPException if the song is not found. \"\"\" try : row = db . query ( MusicLibrary ) . filter ( MusicLibrary . id == id ) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"Song not found\" ) return { \"id\" : id , \"row\" : row } finally : db . close () list_all_albums ( user = Depends ( login_manager ), db = Depends ( get_db )) Lists all albums in the music_library table, ordered by release date. Parameters : None Returns : A list of dictionaries, each containing the album name, album folder, and release year, ordered by release year. Source code in routes/music.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @router . get ( \"/albums\" , tags = [ \"songs\" ]) def list_all_albums ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all albums in the music_library table, ordered by release date. - **Parameters**: None - **Returns**: A list of dictionaries, each containing the album name, album folder, and release year, ordered by release year. \"\"\" try : query = ( db . query ( MusicLibrary . album , MusicLibrary . album_folder , MusicLibrary . year ) . distinct () . order_by ( MusicLibrary . year . asc ()) ) return [{ \"album\" : row . album , \"album_folder\" : row . album_folder } for row in query . all ()] finally : db . close () list_all_albums_from_artist ( artist_folder , user = Depends ( login_manager ), db = Depends ( get_db )) Lists all albums by a specific artist in the music_library table, ordered by release date. Parameters : artist_folder : ArtistFolderResponse object containing the artist's folder name. user : User object, automatically provided by the login_manager dependency. Returns : A list of album names for the given artist, ordered by release date. Source code in routes/music.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @router . post ( \"/albums\" , tags = [ \"songs\" ]) def list_all_albums_from_artist ( artist_folder : ArtistFolderResponse , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all albums by a specific artist in the music_library table, ordered by release date. - **Parameters**: - **artist_folder**: ArtistFolderResponse object containing the artist's folder name. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A list of album names for the given artist, ordered by release date. \"\"\" if artist_folder is None or artist_folder . artist_folder is None : raise HTTPException ( status_code = 400 , detail = \"Missing artist_folder parameter\" ) try : query = ( db . query ( MusicLibrary . album ) . filter ( MusicLibrary . artist_folder == artist_folder . artist_folder ) . distinct () ) return [ row . album for row in query . all ()] finally : db . close () list_all_artists ( user = Depends ( login_manager ), db = Depends ( get_db )) Lists all artists in the music_library table in alphabetical order. Parameters : None Returns : A list of artist names in alphabetical order. Source code in routes/music.py 119 120 121 122 123 124 125 126 127 128 129 130 131 @router . get ( \"/artists\" , tags = [ \"songs\" ]) def list_all_artists ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all artists in the music_library table in alphabetical order. - **Parameters**: None - **Returns**: A list of artist names in alphabetical order. \"\"\" try : query = ( db . query ( MusicLibrary . artist_folder ) . distinct () . order_by ( MusicLibrary . artist_folder . asc ())) return [ row . artist_folder for row in query . all ()] finally : db . close () list_all_songs_from_album ( album_folder = None , user = Depends ( login_manager ), db = Depends ( get_db )) Lists all songs from a specific album in the music_library table. Parameters : album_folder : AlbumResponse object containing the album's folder name. user : User object, automatically provided by the login_manager dependency. Returns : A list of dictionaries, each containing the track number and title of a song from the specified album. Source code in routes/music.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 @router . post ( \"/songs\" , tags = [ \"songs\" ]) def list_all_songs_from_album ( album_folder : AlbumResponse = None , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all songs from a specific album in the music_library table. - **Parameters**: - **album_folder**: AlbumResponse object containing the album's folder name. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A list of dictionaries, each containing the track number and title of a song from the specified album. \"\"\" if album_folder is None or album_folder . album_folder is None : raise HTTPException ( status_code = 400 , detail = \"Missing album_folder parameter\" ) try : query = db . query ( MusicLibrary ) . filter ( MusicLibrary . album_folder == album_folder . album_folder ) return [ { \"tracknumber\" : row . tracknumber , \"title\" : row . title } for row in query . order_by ( MusicLibrary . tracknumber . asc ()) . all () ] finally : db . close () list_all_songs_from_artist_and_album ( query , user = Depends ( login_manager ), db = Depends ( get_db )) Lists all songs by a specific artist and from a specific album in the music_library table. Parameters : query : ArtistAlbumResponse object containing the artist's name and album title. user : User object, automatically provided by the login_manager dependency. Returns : A list of dictionaries, each containing the track number, file path, and title of a song from the specified artist and album. Source code in routes/music.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @router . post ( \"/songs/by_artist_and_album\" , tags = [ \"songs\" ]) def list_all_songs_from_artist_and_album ( query : ArtistAlbumResponse , user = Depends ( login_manager ), db : Session = Depends ( get_db ) ): \"\"\" Lists all songs by a specific artist and from a specific album in the music_library table. - **Parameters**: - **query**: ArtistAlbumResponse object containing the artist's name and album title. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A list of dictionaries, each containing the track number, file path, and title of a song from the specified artist and album. \"\"\" artist = query . artist album = query . album try : query = db . query ( MusicLibrary ) . filter ( MusicLibrary . artist == artist , MusicLibrary . album == album ) return [ { \"tracknumber\" : row . tracknumber , \"path\" : row . filepath , \"title\" : row . title } for row in query . order_by ( MusicLibrary . tracknumber . asc ()) . all () ] finally : db . close ()","title":"Music"},{"location":"endpoints/music/#documentation-for-endpointsmusicpy","text":"This module contains the endpoints for operations on the music database. It provides routes for searching for music by song title and artist.","title":"Documentation for endpoints/music.py"},{"location":"endpoints/music/#routes.music.add_row","text":"Adds a new song to the music_library table. Parameters : query : AddSongToMusicLibrary object containing the song details to be added. user : User object, automatically provided by the login_manager dependency. Returns : A message indicating successful addition of the song. Source code in routes/music.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @router . post ( \"/add\" , tags = [ \"songs\" ]) def add_row ( query : AddSongToMusicLibrary , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Adds a new song to the music_library table. - **Parameters**: - **query**: AddSongToMusicLibrary object containing the song details to be added. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A message indicating successful addition of the song. \"\"\" try : max_id = db . query ( func . max ( MusicLibrary . id )) . scalar () # Get the maximum id from the music_library table if max_id is None : max_id = 0 # If the table is empty, set max_id to 0 # insert into the table stmt = insert ( MusicLibrary ) . values ( id = max_id + 1 , # Set the id to one more than the current maximum filename = query . filename , filepath = query . filepath , album_folder = query . album_folder , artist_folder = query . artist_folder , filesize = query . filesize , title = query . title , artist = query . artist , album = query . album , year = query . year , tracknumber = query . tracknumber , genre = query . genre , top_5_genres = query . top_5_genres , ) db . execute ( stmt ) db . commit () return { \"message\" : \"Row added successfully\" } finally : db . close ()","title":"add_row"},{"location":"endpoints/music/#routes.music.count_rows","text":"Returns the total number of rows in the music_library table. Parameters : None Returns : An integer representing the total number of rows in the music_library table. Source code in routes/music.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @router . get ( \"/count\" , tags = [ \"songs\" ]) def count_rows ( db : Session = Depends ( get_db )): \"\"\" Returns the total number of rows in the music_library table. - **Parameters**: None - **Returns**: An integer representing the total number of rows in the music_library table. \"\"\" try : result = db . execute ( text ( \"SELECT COUNT(*) FROM music_library\" )) count = result . scalar () return count finally : db . close ()","title":"count_rows"},{"location":"endpoints/music/#routes.music.delete_row","text":"Deletes a specific song from the music_library table by its ID. Parameters : id : Integer, the ID of the song to delete. user : User object, automatically provided by the login_manager dependency. Returns : A message indicating successful deletion of the song. Raises a 404 HTTPException if the song is not found. Source code in routes/music.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @router . delete ( \"/delete/ {id} \" , tags = [ \"songs\" ]) def delete_row ( id : int , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Deletes a specific song from the music_library table by its ID. - **Parameters**: - **id**: Integer, the ID of the song to delete. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A message indicating successful deletion of the song. Raises a 404 HTTPException if the song is not found. \"\"\" try : row = db . query ( MusicLibrary ) . get ( id ) if row is None : raise HTTPException ( status_code = 404 , detail = \"Row not found\" ) db . delete ( row ) db . commit () return { \"message\" : \"Row deleted successfully\" } finally : db . close ()","title":"delete_row"},{"location":"endpoints/music/#routes.music.get_album_folder_by_artist_and_album","text":"Retrieves the album folder for a specific artist and album combination in the music_library table. Parameters : query : ArtistAlbumResponse object containing the artist's name and album title. user : User object, automatically provided by the login_manager dependency. Returns : A dictionary containing the album folder name. Raises a 404 HTTPException if the album is not found. Source code in routes/music.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 @router . post ( \"/album_folder_by_artist_and_album\" , tags = [ \"songs\" ]) def get_album_folder_by_artist_and_album ( query : ArtistAlbumResponse , user = Depends ( login_manager ), db : Session = Depends ( get_db ) ): \"\"\" Retrieves the album folder for a specific artist and album combination in the music_library table. - **Parameters**: - **query**: ArtistAlbumResponse object containing the artist's name and album title. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A dictionary containing the album folder name. Raises a 404 HTTPException if the album is not found. \"\"\" artist = query . artist album = query . album try : row = db . query ( MusicLibrary . album_folder ) . filter ( MusicLibrary . artist == artist , MusicLibrary . album == album ) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"Album not found\" ) return { \"album_folder\" : row . album_folder } finally : db . close ()","title":"get_album_folder_by_artist_and_album"},{"location":"endpoints/music/#routes.music.get_random_row","text":"Retrieves a random song from the music_library table. Parameters : user : User object, automatically provided by the login_manager dependency. Returns : A dictionary containing the ID of the randomly selected song and the song's row data. Source code in routes/music.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @router . get ( \"/random\" , tags = [ \"songs\" ]) def get_random_row ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieves a random song from the music_library table. - **Parameters**: - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A dictionary containing the ID of the randomly selected song and the song's row data. \"\"\" try : count = db . query ( MusicLibrary ) . count () random_id = randint ( 1 , count ) row = db . query ( MusicLibrary ) . filter ( MusicLibrary . id == random_id ) . first () return { \"id\" : random_id , \"row\" : row } finally : db . close ()","title":"get_random_row"},{"location":"endpoints/music/#routes.music.get_song_by_id","text":"Fetches a specific song from the music_library table by its ID. Parameters : id : Integer, the ID of the song to retrieve. user : User object, automatically provided by the login_manager dependency. Returns : A dictionary containing the ID of the song and the song's row data. Raises a 404 HTTPException if the song is not found. Source code in routes/music.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @router . get ( \"/song/ {id} \" , tags = [ \"songs\" ]) def get_song_by_id ( id : int , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches a specific song from the music_library table by its ID. - **Parameters**: - **id**: Integer, the ID of the song to retrieve. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A dictionary containing the ID of the song and the song's row data. Raises a 404 HTTPException if the song is not found. \"\"\" try : row = db . query ( MusicLibrary ) . filter ( MusicLibrary . id == id ) . first () if row is None : raise HTTPException ( status_code = 404 , detail = \"Song not found\" ) return { \"id\" : id , \"row\" : row } finally : db . close ()","title":"get_song_by_id"},{"location":"endpoints/music/#routes.music.list_all_albums","text":"Lists all albums in the music_library table, ordered by release date. Parameters : None Returns : A list of dictionaries, each containing the album name, album folder, and release year, ordered by release year. Source code in routes/music.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @router . get ( \"/albums\" , tags = [ \"songs\" ]) def list_all_albums ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all albums in the music_library table, ordered by release date. - **Parameters**: None - **Returns**: A list of dictionaries, each containing the album name, album folder, and release year, ordered by release year. \"\"\" try : query = ( db . query ( MusicLibrary . album , MusicLibrary . album_folder , MusicLibrary . year ) . distinct () . order_by ( MusicLibrary . year . asc ()) ) return [{ \"album\" : row . album , \"album_folder\" : row . album_folder } for row in query . all ()] finally : db . close ()","title":"list_all_albums"},{"location":"endpoints/music/#routes.music.list_all_albums_from_artist","text":"Lists all albums by a specific artist in the music_library table, ordered by release date. Parameters : artist_folder : ArtistFolderResponse object containing the artist's folder name. user : User object, automatically provided by the login_manager dependency. Returns : A list of album names for the given artist, ordered by release date. Source code in routes/music.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @router . post ( \"/albums\" , tags = [ \"songs\" ]) def list_all_albums_from_artist ( artist_folder : ArtistFolderResponse , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all albums by a specific artist in the music_library table, ordered by release date. - **Parameters**: - **artist_folder**: ArtistFolderResponse object containing the artist's folder name. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A list of album names for the given artist, ordered by release date. \"\"\" if artist_folder is None or artist_folder . artist_folder is None : raise HTTPException ( status_code = 400 , detail = \"Missing artist_folder parameter\" ) try : query = ( db . query ( MusicLibrary . album ) . filter ( MusicLibrary . artist_folder == artist_folder . artist_folder ) . distinct () ) return [ row . album for row in query . all ()] finally : db . close ()","title":"list_all_albums_from_artist"},{"location":"endpoints/music/#routes.music.list_all_artists","text":"Lists all artists in the music_library table in alphabetical order. Parameters : None Returns : A list of artist names in alphabetical order. Source code in routes/music.py 119 120 121 122 123 124 125 126 127 128 129 130 131 @router . get ( \"/artists\" , tags = [ \"songs\" ]) def list_all_artists ( user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all artists in the music_library table in alphabetical order. - **Parameters**: None - **Returns**: A list of artist names in alphabetical order. \"\"\" try : query = ( db . query ( MusicLibrary . artist_folder ) . distinct () . order_by ( MusicLibrary . artist_folder . asc ())) return [ row . artist_folder for row in query . all ()] finally : db . close ()","title":"list_all_artists"},{"location":"endpoints/music/#routes.music.list_all_songs_from_album","text":"Lists all songs from a specific album in the music_library table. Parameters : album_folder : AlbumResponse object containing the album's folder name. user : User object, automatically provided by the login_manager dependency. Returns : A list of dictionaries, each containing the track number and title of a song from the specified album. Source code in routes/music.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 @router . post ( \"/songs\" , tags = [ \"songs\" ]) def list_all_songs_from_album ( album_folder : AlbumResponse = None , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Lists all songs from a specific album in the music_library table. - **Parameters**: - **album_folder**: AlbumResponse object containing the album's folder name. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A list of dictionaries, each containing the track number and title of a song from the specified album. \"\"\" if album_folder is None or album_folder . album_folder is None : raise HTTPException ( status_code = 400 , detail = \"Missing album_folder parameter\" ) try : query = db . query ( MusicLibrary ) . filter ( MusicLibrary . album_folder == album_folder . album_folder ) return [ { \"tracknumber\" : row . tracknumber , \"title\" : row . title } for row in query . order_by ( MusicLibrary . tracknumber . asc ()) . all () ] finally : db . close ()","title":"list_all_songs_from_album"},{"location":"endpoints/music/#routes.music.list_all_songs_from_artist_and_album","text":"Lists all songs by a specific artist and from a specific album in the music_library table. Parameters : query : ArtistAlbumResponse object containing the artist's name and album title. user : User object, automatically provided by the login_manager dependency. Returns : A list of dictionaries, each containing the track number, file path, and title of a song from the specified artist and album. Source code in routes/music.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @router . post ( \"/songs/by_artist_and_album\" , tags = [ \"songs\" ]) def list_all_songs_from_artist_and_album ( query : ArtistAlbumResponse , user = Depends ( login_manager ), db : Session = Depends ( get_db ) ): \"\"\" Lists all songs by a specific artist and from a specific album in the music_library table. - **Parameters**: - **query**: ArtistAlbumResponse object containing the artist's name and album title. - **user**: User object, automatically provided by the login_manager dependency. - **Returns**: A list of dictionaries, each containing the track number, file path, and title of a song from the specified artist and album. \"\"\" artist = query . artist album = query . album try : query = db . query ( MusicLibrary ) . filter ( MusicLibrary . artist == artist , MusicLibrary . album == album ) return [ { \"tracknumber\" : row . tracknumber , \"path\" : row . filepath , \"title\" : row . title } for row in query . order_by ( MusicLibrary . tracknumber . asc ()) . all () ] finally : db . close ()","title":"list_all_songs_from_artist_and_album"},{"location":"endpoints/openl3/","text":"Documentation for endpoints/openl3.py This module contains the endpoints for the OpenL3 service. It provides routes for extracting audio embeddings using the OpenL3 model. The embeddings can then be used to perform similarity searches on the embeddings using the Milvus service. get_embeddings ( file_path , user = Depends ( login_manager ), db = Depends ( get_db )) Retrieves the embeddings for a specified audio file. This function loads a model from MinIO, retrieves the specified audio file as a temporary file, computes the embeddings using the loaded model, and then cleans up the temporary file. If successful, it returns an EmbeddingResponse object containing the file name and its embeddings. If the process fails, it raises an HTTPException with status code 500. Parameters: - file_path (str): The path to the audio file for which embeddings are to be computed. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - EmbeddingResponse: An object containing the file name and its computed embeddings. Source code in routes/openl3.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @router . post ( \"/embeddings/\" , response_model = EmbeddingResponse , tags = [ \"OpenL3\" ]) def get_embeddings ( file_path : str , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieves the embeddings for a specified audio file. This function loads a model from MinIO, retrieves the specified audio file as a temporary file, computes the embeddings using the loaded model, and then cleans up the temporary file. If successful, it returns an EmbeddingResponse object containing the file name and its embeddings. If the process fails, it raises an HTTPException with status code 500. Parameters: - file_path (str): The path to the audio file for which embeddings are to be computed. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - EmbeddingResponse: An object containing the file name and its computed embeddings. \"\"\" print ( f \"Starting to get embeddings for file: { file_path } \" ) try : embedding_512_model = load_model_from_minio () temp_file_path = get_temp_file_from_minio ( file_path ) # Compute embeddings using the temporary file path vector = embedding_512_model . compute ( temp_file_path ) embedding = vector . mean ( axis = 0 ) # Clean up the temporary file os . unlink ( temp_file_path ) print ( f \"Successfully processed embeddings for file: { file_path } \" ) return EmbeddingResponse ( file_name = file_path , embedding = embedding . tolist ()) except Exception as e : print ( f \"Failed to get embeddings for file: { file_path } . Error: { e } \" ) raise HTTPException ( status_code = 500 , detail = f \"Failed to process the request: { e } \" )","title":"OpenL3"},{"location":"endpoints/openl3/#documentation-for-endpointsopenl3py","text":"This module contains the endpoints for the OpenL3 service. It provides routes for extracting audio embeddings using the OpenL3 model. The embeddings can then be used to perform similarity searches on the embeddings using the Milvus service.","title":"Documentation for endpoints/openl3.py"},{"location":"endpoints/openl3/#routes.openl3.get_embeddings","text":"Retrieves the embeddings for a specified audio file. This function loads a model from MinIO, retrieves the specified audio file as a temporary file, computes the embeddings using the loaded model, and then cleans up the temporary file. If successful, it returns an EmbeddingResponse object containing the file name and its embeddings. If the process fails, it raises an HTTPException with status code 500. Parameters: - file_path (str): The path to the audio file for which embeddings are to be computed. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - EmbeddingResponse: An object containing the file name and its computed embeddings. Source code in routes/openl3.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @router . post ( \"/embeddings/\" , response_model = EmbeddingResponse , tags = [ \"OpenL3\" ]) def get_embeddings ( file_path : str , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Retrieves the embeddings for a specified audio file. This function loads a model from MinIO, retrieves the specified audio file as a temporary file, computes the embeddings using the loaded model, and then cleans up the temporary file. If successful, it returns an EmbeddingResponse object containing the file name and its embeddings. If the process fails, it raises an HTTPException with status code 500. Parameters: - file_path (str): The path to the audio file for which embeddings are to be computed. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - EmbeddingResponse: An object containing the file name and its computed embeddings. \"\"\" print ( f \"Starting to get embeddings for file: { file_path } \" ) try : embedding_512_model = load_model_from_minio () temp_file_path = get_temp_file_from_minio ( file_path ) # Compute embeddings using the temporary file path vector = embedding_512_model . compute ( temp_file_path ) embedding = vector . mean ( axis = 0 ) # Clean up the temporary file os . unlink ( temp_file_path ) print ( f \"Successfully processed embeddings for file: { file_path } \" ) return EmbeddingResponse ( file_name = file_path , embedding = embedding . tolist ()) except Exception as e : print ( f \"Failed to get embeddings for file: { file_path } . Error: { e } \" ) raise HTTPException ( status_code = 500 , detail = f \"Failed to process the request: { e } \" )","title":"get_embeddings"},{"location":"endpoints/spotinite/","text":"Documentation for endpoints/spotinite.py This module contains the endpoints for what we call, the 'Spotinite service'. It provides routes for using the python spotipy library to interact with the Cyanite API. The Cyanite API is a music recommendation service. It uses the Spotify's ID to identify songs and can recommend songs based on a given artist or band name and a track title. similar_tracks ( query , user = Depends ( login_manager ), db = Depends ( get_db )) async Fetches and returns a list of tracks similar to the specified song and artist. This endpoint takes a song title and artist as input, retrieves a Spotify ID for the song, and then fetches a list of similar tracks based on that ID. It aims to return 3 similar tracks that are not by the same artist as the input song, if possible. If not enough non-artist matches are found, it will include tracks by the same artist in the response. Parameters: - query (SpotiniteQuery): The query object containing the title and artist of the song. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - List[SpotiniteResponse]: A list of similar tracks, each represented by a SpotiniteResponse object. Source code in routes/spotinite.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @router . post ( \"/similar_tracks\" , response_model = List [ SpotiniteResponse ], tags = [ \"spotinite\" ]) async def similar_tracks ( query : SpotiniteQuery , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches and returns a list of tracks similar to the specified song and artist. This endpoint takes a song title and artist as input, retrieves a Spotify ID for the song, and then fetches a list of similar tracks based on that ID. It aims to return 3 similar tracks that are not by the same artist as the input song, if possible. If not enough non-artist matches are found, it will include tracks by the same artist in the response. Parameters: - query (SpotiniteQuery): The query object containing the title and artist of the song. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - List[SpotiniteResponse]: A list of similar tracks, each represented by a SpotiniteResponse object. \"\"\" try : spotify_id = get_track_id ( query . title , query . artist ) similar_track_ids = fetch_similar_tracks ( spotify_id ) except Exception as e : raise HTTPException ( status_code = 400 , detail = str ( e )) # Fetch 15 similar tracks and return the first 3 that are not by the same artist if possible similar_tracks = [] added_artists = set () backup_tracks = [] for track_id in similar_track_ids : track_info = get_track_info ( track_id ) artist_lower = track_info [ 'Artist' ] . lower () if artist_lower != query . artist . lower () and artist_lower not in added_artists : similar_tracks . append ( track_info ) added_artists . add ( artist_lower ) else : backup_tracks . append ( track_info ) if len ( similar_tracks ) == 3 : break if len ( similar_tracks ) < 3 : similar_tracks . extend ( backup_tracks [: 3 - len ( similar_tracks )]) return similar_tracks","title":"Spotinite"},{"location":"endpoints/spotinite/#documentation-for-endpointsspotinitepy","text":"This module contains the endpoints for what we call, the 'Spotinite service'. It provides routes for using the python spotipy library to interact with the Cyanite API. The Cyanite API is a music recommendation service. It uses the Spotify's ID to identify songs and can recommend songs based on a given artist or band name and a track title.","title":"Documentation for endpoints/spotinite.py"},{"location":"endpoints/spotinite/#routes.spotinite.similar_tracks","text":"Fetches and returns a list of tracks similar to the specified song and artist. This endpoint takes a song title and artist as input, retrieves a Spotify ID for the song, and then fetches a list of similar tracks based on that ID. It aims to return 3 similar tracks that are not by the same artist as the input song, if possible. If not enough non-artist matches are found, it will include tracks by the same artist in the response. Parameters: - query (SpotiniteQuery): The query object containing the title and artist of the song. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - List[SpotiniteResponse]: A list of similar tracks, each represented by a SpotiniteResponse object. Source code in routes/spotinite.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @router . post ( \"/similar_tracks\" , response_model = List [ SpotiniteResponse ], tags = [ \"spotinite\" ]) async def similar_tracks ( query : SpotiniteQuery , user = Depends ( login_manager ), db : Session = Depends ( get_db )): \"\"\" Fetches and returns a list of tracks similar to the specified song and artist. This endpoint takes a song title and artist as input, retrieves a Spotify ID for the song, and then fetches a list of similar tracks based on that ID. It aims to return 3 similar tracks that are not by the same artist as the input song, if possible. If not enough non-artist matches are found, it will include tracks by the same artist in the response. Parameters: - query (SpotiniteQuery): The query object containing the title and artist of the song. - user: The current user object, automatically provided by the login_manager dependency. - db: The database session, automatically provided by the get_db dependency. Returns: - List[SpotiniteResponse]: A list of similar tracks, each represented by a SpotiniteResponse object. \"\"\" try : spotify_id = get_track_id ( query . title , query . artist ) similar_track_ids = fetch_similar_tracks ( spotify_id ) except Exception as e : raise HTTPException ( status_code = 400 , detail = str ( e )) # Fetch 15 similar tracks and return the first 3 that are not by the same artist if possible similar_tracks = [] added_artists = set () backup_tracks = [] for track_id in similar_track_ids : track_info = get_track_info ( track_id ) artist_lower = track_info [ 'Artist' ] . lower () if artist_lower != query . artist . lower () and artist_lower not in added_artists : similar_tracks . append ( track_info ) added_artists . add ( artist_lower ) else : backup_tracks . append ( track_info ) if len ( similar_tracks ) == 3 : break if len ( similar_tracks ) < 3 : similar_tracks . extend ( backup_tracks [: 3 - len ( similar_tracks )]) return similar_tracks","title":"similar_tracks"},{"location":"endpoints/uploaded/","text":"Documentation for endpoints/uploaded.py This module provides endpoints to interact with a MiniO bucket for storing and retrieving user uploaded songs.","title":"Uploaded"},{"location":"endpoints/uploaded/#documentation-for-endpointsuploadedpy","text":"This module provides endpoints to interact with a MiniO bucket for storing and retrieving user uploaded songs.","title":"Documentation for endpoints/uploaded.py"},{"location":"services/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy - Deploy the documentation to GitHub Pages. Project layout . \u251c\u2500\u2500 app.py \u251c\u2500\u2500 docker-compose.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 core \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 database.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 music.db \u2502 \u251c\u2500\u2500 gui \u2502 \u2514\u2500\u2500 templates \u2502 \u2514\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 users.py \u2502 \u251c\u2500\u2500 routes \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u2514\u2500\u2500 spotinite.py \u2502 \u251c\u2500\u2500 services \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u2514\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_files.py","title":"Welcome to MkDocs"},{"location":"services/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"services/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy - Deploy the documentation to GitHub Pages.","title":"Commands"},{"location":"services/#project-layout","text":". \u251c\u2500\u2500 app.py \u251c\u2500\u2500 docker-compose.yaml \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 core \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 database.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 data \u2502 \u2514\u2500\u2500 music.db \u2502 \u251c\u2500\u2500 gui \u2502 \u2514\u2500\u2500 templates \u2502 \u2514\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u251c\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 users.py \u2502 \u251c\u2500\u2500 routes \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 music.py \u2502 \u2514\u2500\u2500 spotinite.py \u2502 \u251c\u2500\u2500 services \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 lyrics.py \u2502 \u251c\u2500\u2500 milvus.py \u2502 \u251c\u2500\u2500 minio.py \u2502 \u2514\u2500\u2500 spotinite.py \u2502 \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_files.py","title":"Project layout"},{"location":"services/auth/","text":"Documentation for services/auth.py This module provides authentication utilities for a web application, including user loading and password hashing. It utilizes the Passlib library for secure password hashing and integrates with the application's login management system to retrieve users based on their email address. get_user ( email ) Retrieves a user from the database by their email address. This function is decorated with @login_manager.user_loader, indicating it's used by Flask-Login to load a user from a session. It queries the database for a user with the given email and returns the user object if found. Parameters: Name Type Description Default email str The email address of the user to retrieve. required Returns: Name Type Description User The user object if found, otherwise None. Source code in services/auth.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @login_manager . user_loader () def get_user ( email : str ): \"\"\" Retrieves a user from the database by their email address. This function is decorated with @login_manager.user_loader, indicating it's used by Flask-Login to load a user from a session. It queries the database for a user with the given email and returns the user object if found. Args: email (str): The email address of the user to retrieve. Returns: User: The user object if found, otherwise None. \"\"\" db = SessionLocal () try : return db . query ( User ) . filter ( User . email == email ) . first () finally : db . close () hash_password ( password ) Hashes a password using the bcrypt algorithm. This function uses Passlib's CryptContext for secure password hashing. The 'bcrypt' scheme is specified, with 'deprecated' set to 'auto' to automatically handle deprecated hash formats. Parameters: Name Type Description Default password str The plaintext password to hash. required Returns: Name Type Description str str The hashed password. Source code in services/auth.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def hash_password ( password : str ) -> str : \"\"\" Hashes a password using the bcrypt algorithm. This function uses Passlib's CryptContext for secure password hashing. The 'bcrypt' scheme is specified, with 'deprecated' set to 'auto' to automatically handle deprecated hash formats. Args: password (str): The plaintext password to hash. Returns: str: The hashed password. \"\"\" pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) return pwd_context . hash ( password )","title":"Auth"},{"location":"services/auth/#documentation-for-servicesauthpy","text":"This module provides authentication utilities for a web application, including user loading and password hashing. It utilizes the Passlib library for secure password hashing and integrates with the application's login management system to retrieve users based on their email address.","title":"Documentation for services/auth.py"},{"location":"services/auth/#services.auth.get_user","text":"Retrieves a user from the database by their email address. This function is decorated with @login_manager.user_loader, indicating it's used by Flask-Login to load a user from a session. It queries the database for a user with the given email and returns the user object if found. Parameters: Name Type Description Default email str The email address of the user to retrieve. required Returns: Name Type Description User The user object if found, otherwise None. Source code in services/auth.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @login_manager . user_loader () def get_user ( email : str ): \"\"\" Retrieves a user from the database by their email address. This function is decorated with @login_manager.user_loader, indicating it's used by Flask-Login to load a user from a session. It queries the database for a user with the given email and returns the user object if found. Args: email (str): The email address of the user to retrieve. Returns: User: The user object if found, otherwise None. \"\"\" db = SessionLocal () try : return db . query ( User ) . filter ( User . email == email ) . first () finally : db . close ()","title":"get_user"},{"location":"services/auth/#services.auth.hash_password","text":"Hashes a password using the bcrypt algorithm. This function uses Passlib's CryptContext for secure password hashing. The 'bcrypt' scheme is specified, with 'deprecated' set to 'auto' to automatically handle deprecated hash formats. Parameters: Name Type Description Default password str The plaintext password to hash. required Returns: Name Type Description str str The hashed password. Source code in services/auth.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def hash_password ( password : str ) -> str : \"\"\" Hashes a password using the bcrypt algorithm. This function uses Passlib's CryptContext for secure password hashing. The 'bcrypt' scheme is specified, with 'deprecated' set to 'auto' to automatically handle deprecated hash formats. Args: password (str): The plaintext password to hash. Returns: str: The hashed password. \"\"\" pwd_context = CryptContext ( schemes = [ \"bcrypt\" ], deprecated = \"auto\" ) return pwd_context . hash ( password )","title":"hash_password"},{"location":"services/favorites/","text":"Documentation for services/favorites.py This module provides functionality to interact with the MusicLibrary database, specifically for retrieving song IDs based on file paths. It includes a function that queries the MusicLibrary table to find a song by its file path and return the song's ID. get_song_id_by_filepath ( db , file_path ) Retrieves the ID of a song from the MusicLibrary table based on its file path. Parameters: Name Type Description Default db Session The SQLAlchemy session for database access. required file_path SongPath The file path of the song. required Returns: Name Type Description int int The ID of the song if found, otherwise None. Source code in services/favorites.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def get_song_id_by_filepath ( db : Session , file_path : SongPath ) -> int : \"\"\" Retrieves the ID of a song from the MusicLibrary table based on its file path. Args: db (Session): The SQLAlchemy session for database access. file_path (SongPath): The file path of the song. Returns: int: The ID of the song if found, otherwise None. \"\"\" song = db . query ( MusicLibrary ) . filter ( MusicLibrary . filepath == file_path ) . first () if song : return song . id else : return None","title":"Favorites"},{"location":"services/favorites/#documentation-for-servicesfavoritespy","text":"This module provides functionality to interact with the MusicLibrary database, specifically for retrieving song IDs based on file paths. It includes a function that queries the MusicLibrary table to find a song by its file path and return the song's ID.","title":"Documentation for services/favorites.py"},{"location":"services/favorites/#services.favorites.get_song_id_by_filepath","text":"Retrieves the ID of a song from the MusicLibrary table based on its file path. Parameters: Name Type Description Default db Session The SQLAlchemy session for database access. required file_path SongPath The file path of the song. required Returns: Name Type Description int int The ID of the song if found, otherwise None. Source code in services/favorites.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def get_song_id_by_filepath ( db : Session , file_path : SongPath ) -> int : \"\"\" Retrieves the ID of a song from the MusicLibrary table based on its file path. Args: db (Session): The SQLAlchemy session for database access. file_path (SongPath): The file path of the song. Returns: int: The ID of the song if found, otherwise None. \"\"\" song = db . query ( MusicLibrary ) . filter ( MusicLibrary . filepath == file_path ) . first () if song : return song . id else : return None","title":"get_song_id_by_filepath"},{"location":"services/lyrics/","text":"Documentation for services/lyrics.py This module provides a function to fetch song lyrics using the Lyrics.ovh API. It includes error handling for request failures and cases where lyrics are not found. fetch_lyrics ( artist , title ) Fetches the lyrics for a given song by artist and title. Parameters: Name Type Description Default artist str The name of the artist. required title str The title of the song. required Returns: Name Type Description str str The lyrics of the song if found, otherwise a message indicating no lyrics were found. Source code in services/lyrics.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def fetch_lyrics ( artist : str , title : str ) -> str : \"\"\" Fetches the lyrics for a given song by artist and title. Args: artist (str): The name of the artist. title (str): The title of the song. Returns: str: The lyrics of the song if found, otherwise a message indicating no lyrics were found. \"\"\" encoded_artist = urllib . parse . quote ( artist ) encoded_song = urllib . parse . quote ( title ) try : response = requests . get ( f \"https://api.lyrics.ovh/v1/ { encoded_artist } / { encoded_song } \" , timeout = 7 ) response . raise_for_status () except requests . exceptions . RequestException : return \"No lyrics found for this song.\" json_response = response . json () if 'error' in json_response : return \"No lyrics found for this song.\" return json_response [ 'lyrics' ]","title":"Lyrics"},{"location":"services/lyrics/#documentation-for-serviceslyricspy","text":"This module provides a function to fetch song lyrics using the Lyrics.ovh API. It includes error handling for request failures and cases where lyrics are not found.","title":"Documentation for services/lyrics.py"},{"location":"services/lyrics/#services.lyrics.fetch_lyrics","text":"Fetches the lyrics for a given song by artist and title. Parameters: Name Type Description Default artist str The name of the artist. required title str The title of the song. required Returns: Name Type Description str str The lyrics of the song if found, otherwise a message indicating no lyrics were found. Source code in services/lyrics.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def fetch_lyrics ( artist : str , title : str ) -> str : \"\"\" Fetches the lyrics for a given song by artist and title. Args: artist (str): The name of the artist. title (str): The title of the song. Returns: str: The lyrics of the song if found, otherwise a message indicating no lyrics were found. \"\"\" encoded_artist = urllib . parse . quote ( artist ) encoded_song = urllib . parse . quote ( title ) try : response = requests . get ( f \"https://api.lyrics.ovh/v1/ { encoded_artist } / { encoded_song } \" , timeout = 7 ) response . raise_for_status () except requests . exceptions . RequestException : return \"No lyrics found for this song.\" json_response = response . json () if 'error' in json_response : return \"No lyrics found for this song.\" return json_response [ 'lyrics' ]","title":"fetch_lyrics"},{"location":"services/milvus/","text":"Documentation for services/milvus.py This Python module provides a comprehensive suite of functionalities for interacting with the Milvus vector database, specifically tailored for managing and querying music-related data. It includes capabilities for connecting to Milvus, performing queries, and processing the results for further analysis or visualization. Additionally, it offers utilities for generating visual representations of data, such as genre predictions for music tracks, and converting these visualizations into a format suitable for web display. convert_plot_to_base64 ( fig ) async Converts a matplotlib plot to a base64-encoded string for embedding in web pages or other digital formats. Parameters: Name Type Description Default fig The matplotlib figure to convert. required Returns: Type Description A base64-encoded string representing the plot image. Source code in services/milvus.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 async def convert_plot_to_base64 ( fig ): \"\"\" Converts a matplotlib plot to a base64-encoded string for embedding in web pages or other digital formats. Args: fig: The matplotlib figure to convert. Returns: A base64-encoded string representing the plot image. \"\"\" buf = io . BytesIO () fig . savefig ( buf , format = 'png' ) buf . seek ( 0 ) image_base64 = base64 . b64encode ( buf . read ()) . decode ( 'utf-8' ) return image_base64 create_plot ( class_names , top_5_activations , title , artist ) async Generates a horizontal bar plot visualizing the top 5 music genre predictions for a given track. Parameters: Name Type Description Default class_names List [ str ] The names of the top 5 predicted genres. required top_5_activations List [ float ] The activation values for the top 5 predicted genres. required title str The title of the music track. required artist str The artist of the music track. required Returns: Type Description A matplotlib figure object containing the generated plot. Source code in services/milvus.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 async def create_plot ( class_names : List [ str ], top_5_activations : List [ float ], title : str , artist : str ): \"\"\" Generates a horizontal bar plot visualizing the top 5 music genre predictions for a given track. Args: class_names: The names of the top 5 predicted genres. top_5_activations: The activation values for the top 5 predicted genres. title: The title of the music track. artist: The artist of the music track. Returns: A matplotlib figure object containing the generated plot. \"\"\" fig , ax = plt . subplots ( figsize = ( 6 , 2 )) plt . barh ( class_names , top_5_activations , color = '#60a5fa' , edgecolor = '#cbd5e1' ) plt . title ( f 'Genres for { title } by { artist } ' , color = '#cbd5e1' ) plt . tick_params ( colors = '#cbd5e1' ) ax . set_facecolor ( '#111827' ) fig . patch . set_facecolor ( '#111827' ) return fig extract_plot_data ( entity ) async Extracts data from a single entity for the purpose of generating a genre prediction plot. Parameters: Name Type Description Default entity The entity from which to extract plot data. required Returns: Type Description A tuple containing class names, top 5 activations, title, and artist, ready for plotting. Source code in services/milvus.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 async def extract_plot_data ( entity ): \"\"\" Extracts data from a single entity for the purpose of generating a genre prediction plot. Args: entity: The entity from which to extract plot data. Returns: A tuple containing class names, top 5 activations, title, and artist, ready for plotting. \"\"\" embeddings = entity [ 0 ][ \"predictions\" ] title = entity [ 0 ][ \"title\" ] artist = entity [ 0 ][ \"artist\" ] with open ( 'core/data/mtg_jamendo_genre.json' , 'r' ) as json_file : metadata = json . load ( json_file ) classes = metadata . get ( 'classes' ) embeddings = np . array ( embeddings ) if len ( embeddings . shape ) == 1 : embeddings = embeddings . reshape ( 1 , - 1 ) average_activations = np . mean ( embeddings , axis = 0 ) average_activations_float = average_activations . astype ( np . float32 ) sorted_indices = np . argsort ( average_activations_float ) top_5_classes = sorted_indices [ - 5 :] top_5_activations = average_activations [ top_5_classes ] class_names = np . array ( classes )[ top_5_classes ] return class_names , top_5_activations , title , artist full_hit_to_dict ( hit ) Converts the full details of a Milvus query hit into a dictionary format, including all available entity information. Parameters: Name Type Description Default hit The query hit object returned by Milvus. required Returns: Type Description A dictionary containing detailed information about the query hit. Source code in services/milvus.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def full_hit_to_dict ( hit ): \"\"\" Converts the full details of a Milvus query hit into a dictionary format, including all available entity information. Args: hit: The query hit object returned by Milvus. Returns: A dictionary containing detailed information about the query hit. \"\"\" return { \"id\" : str ( hit . id ), \"distance\" : hit . distance , \"entity\" : { \"path\" : hit . entity . path , \"title\" : hit . entity . title , \"album\" : hit . entity . album , \"artist\" : hit . entity . artist , \"top_5_genres\" : \",\" . join ( hit . entity . top_5_genres ), \"embedding\" : \",\" . join ( map ( str , hit . entity . embedding )), }, } get_milvus_512_collection () Connects to the Milvus database and retrieves the collection specified for 512-dimensional vectors. Returns: Type Description The Milvus Collection object corresponding to the 512-dimensional vector collection. Source code in services/milvus.py 37 38 39 40 41 42 43 44 45 46 47 48 49 def get_milvus_512_collection (): \"\"\" Connects to the Milvus database and retrieves the collection specified for 512-dimensional vectors. Returns: The Milvus Collection object corresponding to the 512-dimensional vector collection. \"\"\" connections . connect ( \"default\" , uri = DEFAULT_SETTINGS . milvus_uri , token = DEFAULT_SETTINGS . milvus_api_key , ) return Collection ( name = DEFAULT_SETTINGS . milvus_512_collection_name ) get_milvus_87_collection () Connects to the Milvus database and retrieves the collection specified for 87-dimensional vectors. Returns: Type Description The Milvus Collection object corresponding to the 87-dimensional vector collection. Source code in services/milvus.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def get_milvus_87_collection (): \"\"\" Connects to the Milvus database and retrieves the collection specified for 87-dimensional vectors. Returns: The Milvus Collection object corresponding to the 87-dimensional vector collection. \"\"\" connections . connect ( \"default\" , uri = DEFAULT_SETTINGS . milvus_uri , token = DEFAULT_SETTINGS . milvus_api_key , ) return Collection ( name = DEFAULT_SETTINGS . milvus_87_collection_name ) ping_milvus () Attempts to connect to the Milvus database using settings from the configuration and performs a simple query to check if the connection is successful. Returns: Type Description A dictionary with a status message indicating the outcome of the connection attempt. Source code in services/milvus.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def ping_milvus (): \"\"\" Attempts to connect to the Milvus database using settings from the configuration and performs a simple query to check if the connection is successful. Returns: A dictionary with a status message indicating the outcome of the connection attempt. \"\"\" try : connections . connect ( \"default\" , uri = DEFAULT_SETTINGS . milvus_uri , token = DEFAULT_SETTINGS . milvus_api_key , ) embedding_512 = Collection ( name = DEFAULT_SETTINGS . milvus_512_collection_name ) response = embedding_512 . query ( expr = \"id in [0]\" , output_fields = [ \"artist\" ], ) if response : return { \"status\" : \"success\" , \"message\" : \"Milvus is running\" } except Exception as e : return { \"status\" : \"error\" , \"message\" : str ( e )} short_hit_to_dict ( hit ) Converts a Milvus query hit into a simplified dictionary format, focusing on essential metadata. Parameters: Name Type Description Default hit The query hit object returned by Milvus. required Returns: Type Description A simplified dictionary containing key information about the query hit. Source code in services/milvus.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def short_hit_to_dict ( hit ): \"\"\" Converts a Milvus query hit into a simplified dictionary format, focusing on essential metadata. Args: hit: The query hit object returned by Milvus. Returns: A simplified dictionary containing key information about the query hit. \"\"\" return { \"title\" : hit . entity . title , \"album\" : hit . entity . album , \"artist\" : hit . entity . artist , \"path\" : hit . entity . path , } sort_entities ( entities ) Sorts a list of entities based on artist uniqueness to prioritize diversity in recommendations. Parameters: Name Type Description Default entities A list of entities (query hits) to be sorted. required Returns: Type Description A sorted list of entities with unique artists prioritized. Source code in services/milvus.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def sort_entities ( entities ): \"\"\" Sorts a list of entities based on artist uniqueness to prioritize diversity in recommendations. Args: entities: A list of entities (query hits) to be sorted. Returns: A sorted list of entities with unique artists prioritized. \"\"\" recommended_artists = set () response_list = [] fallback_list = [] for hit in entities [ 0 ]: hit_dict = short_hit_to_dict ( hit ) if hit_dict [ \"artist\" ] not in recommended_artists : response_list . append ( hit_dict ) recommended_artists . add ( hit_dict [ \"artist\" ]) else : fallback_list . append ( hit_dict ) if len ( response_list ) == 9 : # Stop when we have 9 results break if len ( response_list ) < 9 : response_list . extend ( fallback_list [: 9 - len ( response_list )]) return response_list","title":"Milvus"},{"location":"services/milvus/#documentation-for-servicesmilvuspy","text":"This Python module provides a comprehensive suite of functionalities for interacting with the Milvus vector database, specifically tailored for managing and querying music-related data. It includes capabilities for connecting to Milvus, performing queries, and processing the results for further analysis or visualization. Additionally, it offers utilities for generating visual representations of data, such as genre predictions for music tracks, and converting these visualizations into a format suitable for web display.","title":"Documentation for services/milvus.py"},{"location":"services/milvus/#services.milvus.convert_plot_to_base64","text":"Converts a matplotlib plot to a base64-encoded string for embedding in web pages or other digital formats. Parameters: Name Type Description Default fig The matplotlib figure to convert. required Returns: Type Description A base64-encoded string representing the plot image. Source code in services/milvus.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 async def convert_plot_to_base64 ( fig ): \"\"\" Converts a matplotlib plot to a base64-encoded string for embedding in web pages or other digital formats. Args: fig: The matplotlib figure to convert. Returns: A base64-encoded string representing the plot image. \"\"\" buf = io . BytesIO () fig . savefig ( buf , format = 'png' ) buf . seek ( 0 ) image_base64 = base64 . b64encode ( buf . read ()) . decode ( 'utf-8' ) return image_base64","title":"convert_plot_to_base64"},{"location":"services/milvus/#services.milvus.create_plot","text":"Generates a horizontal bar plot visualizing the top 5 music genre predictions for a given track. Parameters: Name Type Description Default class_names List [ str ] The names of the top 5 predicted genres. required top_5_activations List [ float ] The activation values for the top 5 predicted genres. required title str The title of the music track. required artist str The artist of the music track. required Returns: Type Description A matplotlib figure object containing the generated plot. Source code in services/milvus.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 async def create_plot ( class_names : List [ str ], top_5_activations : List [ float ], title : str , artist : str ): \"\"\" Generates a horizontal bar plot visualizing the top 5 music genre predictions for a given track. Args: class_names: The names of the top 5 predicted genres. top_5_activations: The activation values for the top 5 predicted genres. title: The title of the music track. artist: The artist of the music track. Returns: A matplotlib figure object containing the generated plot. \"\"\" fig , ax = plt . subplots ( figsize = ( 6 , 2 )) plt . barh ( class_names , top_5_activations , color = '#60a5fa' , edgecolor = '#cbd5e1' ) plt . title ( f 'Genres for { title } by { artist } ' , color = '#cbd5e1' ) plt . tick_params ( colors = '#cbd5e1' ) ax . set_facecolor ( '#111827' ) fig . patch . set_facecolor ( '#111827' ) return fig","title":"create_plot"},{"location":"services/milvus/#services.milvus.extract_plot_data","text":"Extracts data from a single entity for the purpose of generating a genre prediction plot. Parameters: Name Type Description Default entity The entity from which to extract plot data. required Returns: Type Description A tuple containing class names, top 5 activations, title, and artist, ready for plotting. Source code in services/milvus.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 async def extract_plot_data ( entity ): \"\"\" Extracts data from a single entity for the purpose of generating a genre prediction plot. Args: entity: The entity from which to extract plot data. Returns: A tuple containing class names, top 5 activations, title, and artist, ready for plotting. \"\"\" embeddings = entity [ 0 ][ \"predictions\" ] title = entity [ 0 ][ \"title\" ] artist = entity [ 0 ][ \"artist\" ] with open ( 'core/data/mtg_jamendo_genre.json' , 'r' ) as json_file : metadata = json . load ( json_file ) classes = metadata . get ( 'classes' ) embeddings = np . array ( embeddings ) if len ( embeddings . shape ) == 1 : embeddings = embeddings . reshape ( 1 , - 1 ) average_activations = np . mean ( embeddings , axis = 0 ) average_activations_float = average_activations . astype ( np . float32 ) sorted_indices = np . argsort ( average_activations_float ) top_5_classes = sorted_indices [ - 5 :] top_5_activations = average_activations [ top_5_classes ] class_names = np . array ( classes )[ top_5_classes ] return class_names , top_5_activations , title , artist","title":"extract_plot_data"},{"location":"services/milvus/#services.milvus.full_hit_to_dict","text":"Converts the full details of a Milvus query hit into a dictionary format, including all available entity information. Parameters: Name Type Description Default hit The query hit object returned by Milvus. required Returns: Type Description A dictionary containing detailed information about the query hit. Source code in services/milvus.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def full_hit_to_dict ( hit ): \"\"\" Converts the full details of a Milvus query hit into a dictionary format, including all available entity information. Args: hit: The query hit object returned by Milvus. Returns: A dictionary containing detailed information about the query hit. \"\"\" return { \"id\" : str ( hit . id ), \"distance\" : hit . distance , \"entity\" : { \"path\" : hit . entity . path , \"title\" : hit . entity . title , \"album\" : hit . entity . album , \"artist\" : hit . entity . artist , \"top_5_genres\" : \",\" . join ( hit . entity . top_5_genres ), \"embedding\" : \",\" . join ( map ( str , hit . entity . embedding )), }, }","title":"full_hit_to_dict"},{"location":"services/milvus/#services.milvus.get_milvus_512_collection","text":"Connects to the Milvus database and retrieves the collection specified for 512-dimensional vectors. Returns: Type Description The Milvus Collection object corresponding to the 512-dimensional vector collection. Source code in services/milvus.py 37 38 39 40 41 42 43 44 45 46 47 48 49 def get_milvus_512_collection (): \"\"\" Connects to the Milvus database and retrieves the collection specified for 512-dimensional vectors. Returns: The Milvus Collection object corresponding to the 512-dimensional vector collection. \"\"\" connections . connect ( \"default\" , uri = DEFAULT_SETTINGS . milvus_uri , token = DEFAULT_SETTINGS . milvus_api_key , ) return Collection ( name = DEFAULT_SETTINGS . milvus_512_collection_name )","title":"get_milvus_512_collection"},{"location":"services/milvus/#services.milvus.get_milvus_87_collection","text":"Connects to the Milvus database and retrieves the collection specified for 87-dimensional vectors. Returns: Type Description The Milvus Collection object corresponding to the 87-dimensional vector collection. Source code in services/milvus.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def get_milvus_87_collection (): \"\"\" Connects to the Milvus database and retrieves the collection specified for 87-dimensional vectors. Returns: The Milvus Collection object corresponding to the 87-dimensional vector collection. \"\"\" connections . connect ( \"default\" , uri = DEFAULT_SETTINGS . milvus_uri , token = DEFAULT_SETTINGS . milvus_api_key , ) return Collection ( name = DEFAULT_SETTINGS . milvus_87_collection_name )","title":"get_milvus_87_collection"},{"location":"services/milvus/#services.milvus.ping_milvus","text":"Attempts to connect to the Milvus database using settings from the configuration and performs a simple query to check if the connection is successful. Returns: Type Description A dictionary with a status message indicating the outcome of the connection attempt. Source code in services/milvus.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def ping_milvus (): \"\"\" Attempts to connect to the Milvus database using settings from the configuration and performs a simple query to check if the connection is successful. Returns: A dictionary with a status message indicating the outcome of the connection attempt. \"\"\" try : connections . connect ( \"default\" , uri = DEFAULT_SETTINGS . milvus_uri , token = DEFAULT_SETTINGS . milvus_api_key , ) embedding_512 = Collection ( name = DEFAULT_SETTINGS . milvus_512_collection_name ) response = embedding_512 . query ( expr = \"id in [0]\" , output_fields = [ \"artist\" ], ) if response : return { \"status\" : \"success\" , \"message\" : \"Milvus is running\" } except Exception as e : return { \"status\" : \"error\" , \"message\" : str ( e )}","title":"ping_milvus"},{"location":"services/milvus/#services.milvus.short_hit_to_dict","text":"Converts a Milvus query hit into a simplified dictionary format, focusing on essential metadata. Parameters: Name Type Description Default hit The query hit object returned by Milvus. required Returns: Type Description A simplified dictionary containing key information about the query hit. Source code in services/milvus.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def short_hit_to_dict ( hit ): \"\"\" Converts a Milvus query hit into a simplified dictionary format, focusing on essential metadata. Args: hit: The query hit object returned by Milvus. Returns: A simplified dictionary containing key information about the query hit. \"\"\" return { \"title\" : hit . entity . title , \"album\" : hit . entity . album , \"artist\" : hit . entity . artist , \"path\" : hit . entity . path , }","title":"short_hit_to_dict"},{"location":"services/milvus/#services.milvus.sort_entities","text":"Sorts a list of entities based on artist uniqueness to prioritize diversity in recommendations. Parameters: Name Type Description Default entities A list of entities (query hits) to be sorted. required Returns: Type Description A sorted list of entities with unique artists prioritized. Source code in services/milvus.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def sort_entities ( entities ): \"\"\" Sorts a list of entities based on artist uniqueness to prioritize diversity in recommendations. Args: entities: A list of entities (query hits) to be sorted. Returns: A sorted list of entities with unique artists prioritized. \"\"\" recommended_artists = set () response_list = [] fallback_list = [] for hit in entities [ 0 ]: hit_dict = short_hit_to_dict ( hit ) if hit_dict [ \"artist\" ] not in recommended_artists : response_list . append ( hit_dict ) recommended_artists . add ( hit_dict [ \"artist\" ]) else : fallback_list . append ( hit_dict ) if len ( response_list ) == 9 : # Stop when we have 9 results break if len ( response_list ) < 9 : response_list . extend ( fallback_list [: 9 - len ( response_list )]) return response_list","title":"sort_entities"},{"location":"services/minio/","text":"Documentation for services/minio.py This module provides utilities for interacting with MinIO, including functions for loading models, managing temporary files, converting artwork to base64, and sanitizing filenames. convert_artwork_to_base64 ( artwork ) Converts artwork data to a base64-encoded string. Parameters: Name Type Description Default artwork The artwork data. required Returns: Type Description str or None: The base64-encoded string, or None if artwork is None. Source code in services/minio.py 49 50 51 52 53 54 55 56 57 58 59 60 61 def convert_artwork_to_base64 ( artwork ): \"\"\" Converts artwork data to a base64-encoded string. Args: artwork: The artwork data. Returns: str or None: The base64-encoded string, or None if artwork is None. \"\"\" if artwork is not None : return base64 . b64encode ( artwork . data ) . decode ( 'utf-8' ) return None delete_temp_file ( temp_file_path ) Deletes a temporary file. Parameters: Name Type Description Default temp_file_path str The path to the temporary file to delete. required Source code in services/minio.py 40 41 42 43 44 45 46 47 def delete_temp_file ( temp_file_path : str ): \"\"\" Deletes a temporary file. Args: temp_file_path (str): The path to the temporary file to delete. \"\"\" os . unlink ( temp_file_path ) get_artwork ( bucket_name , file_name ) Retrieves artwork from a specified bucket and file name, converts it to base64. Parameters: Name Type Description Default bucket_name str The name of the bucket. required file_name str The name of the file. required Returns: Type Description str or None: The base64-encoded artwork, or None if not found or an error occurs. Source code in services/minio.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_artwork ( bucket_name : str , file_name : str ): \"\"\" Retrieves artwork from a specified bucket and file name, converts it to base64. Args: bucket_name (str): The name of the bucket. file_name (str): The name of the file. Returns: str or None: The base64-encoded artwork, or None if not found or an error occurs. \"\"\" try : with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : try : data = minio_client . get_object ( bucket_name , file_name ) temp_file . write ( data . read ()) except S3Error as e : if e . code == 'NoSuchKey' : print ( f \"File { file_name } not found in bucket { bucket_name } .\" ) return None else : raise f = music_tag . load_file ( temp_file . name ) if f [ 'artwork' ] and f [ 'artwork' ] . first is not None : return convert_artwork_to_base64 ( f [ 'artwork' ] . first ) return None finally : os . unlink ( temp_file . name ) get_metadata_and_artwork ( bucket_name , file_name ) Retrieves metadata and artwork for a given file from MinIO, converting artwork to base64. Parameters: Name Type Description Default bucket_name str The name of the bucket. required file_name str The name of the file. required Returns: Name Type Description dict A dictionary containing the metadata and base64-encoded artwork. Source code in services/minio.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_metadata_and_artwork ( bucket_name : str , file_name : str ): \"\"\" Retrieves metadata and artwork for a given file from MinIO, converting artwork to base64. Args: bucket_name (str): The name of the bucket. file_name (str): The name of the file. Returns: dict: A dictionary containing the metadata and base64-encoded artwork. \"\"\" with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : data = minio_client . get_object ( bucket_name , file_name ) temp_file . write ( data . read ()) try : f = music_tag . load_file ( temp_file . name ) metadata = { \"filepath\" : file_name , \"filesize\" : round ( os . path . getsize ( temp_file . name ) / 1024 / 1024 , 2 ), \"title\" : f [ 'title' ] . first or \"Unknown Title\" , \"artist\" : f [ 'artist' ] . first or \"Unknown Artist\" , \"album\" : f [ 'album' ] . first or \"Unknown Album\" , \"year\" : f [ 'year' ] . first or \"Unknown Year\" , \"tracknumber\" : f [ 'tracknumber' ] . first or \"Unknown Track Number\" , \"genre\" : f [ 'genre' ] . first or \"Unknown Genre\" , } if f [ 'artwork' ] and f [ 'artwork' ] . first is not None : metadata [ \"artwork\" ] = convert_artwork_to_base64 ( f [ 'artwork' ] . first ) return metadata finally : os . unlink ( temp_file . name ) get_temp_file_from_minio ( file_name ) Retrieves a file from MinIO and writes it to a temporary file. Parameters: Name Type Description Default file_name str The name of the file to retrieve. required Returns: Name Type Description str The path to the temporary file. Source code in services/minio.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_temp_file_from_minio ( file_name : str ): \"\"\" Retrieves a file from MinIO and writes it to a temporary file. Args: file_name (str): The name of the file to retrieve. Returns: str: The path to the temporary file. \"\"\" with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : response = minio_client . get_object ( DEFAULT_SETTINGS . minio_temp_bucket_name , file_name ) temp_file . write ( response . read ()) return temp_file . name load_model_from_minio () Loads a model from MinIO into a temporary file and returns the model. Returns: Name Type Description EmbeddingsOpenL3 The loaded model. Source code in services/minio.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def load_model_from_minio (): \"\"\" Loads a model from MinIO into a temporary file and returns the model. Returns: EmbeddingsOpenL3: The loaded model. \"\"\" with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : response = minio_client . get_object ( DEFAULT_SETTINGS . minio_openl3_bucket_name , DEFAULT_SETTINGS . minio_openl3_file_name ) temp_file . write ( response . read ()) temp_file . flush () embedding_512_model = EmbeddingsOpenL3 ( graph_path = temp_file . name ) return embedding_512_model sanitize_filename ( filename ) Sanitizes a filename by removing disallowed characters and sequences. Parameters: Name Type Description Default filename str The filename to sanitize. required Returns: Name Type Description str The sanitized filename. Source code in services/minio.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def sanitize_filename ( filename ): \"\"\" Sanitizes a filename by removing disallowed characters and sequences. Args: filename (str): The filename to sanitize. Returns: str: The sanitized filename. \"\"\" replacements = { \"!\" : \"\" , \"@\" : \"\" , \"#\" : \"\" , \"$\" : \"\" , \"%\" : \"\" , \"^\" : \"\" , \"&\" : \"\" , \"*\" : \"\" , \"(\" : \"\" , \")\" : \"\" , \"[\" : \"\" , \"]\" : \"\" , \"{\" : \"\" , \"}\" : \"\" , \";\" : \"\" , \":\" : \"\" , \" \\\" \" : \"\" , \"'\" : \"\" , \",\" : \"\" , \"<\" : \"\" , \">\" : \"\" , \"/\" : \"\" , \"?\" : \"\" , \"`\" : \"\" , \"~\" : \"\" , \"\u00e9\" : \"e\" , \"\u00e8\" : \"e\" , \"\u00ea\" : \"e\" , \"\u00e0\" : \"a\" , \"\u00e2\" : \"a\" , \"\u00f9\" : \"u\" , \"\u00f4\" : \"o\" , \"\u00ee\" : \"i\" , \"\u00e7\" : \"c\" , \"\u00eb\" : \"e\" } has_mp3_extension = filename . lower () . endswith ( '.mp3' ) if has_mp3_extension : base_name , extension = filename [: - 4 ], filename [ - 4 :] else : base_name , extension = filename , '' base_name = base_name . replace ( \"..\" , \"\" ) . replace ( \"//\" , \"\" ) sanitized_base_name = \"\" . join ( replacements . get ( c , c ) for c in base_name if c not in [ ' ' ] and ( c . isalnum () or c in replacements )) if has_mp3_extension : sanitized_base_name = sanitized_base_name . rstrip ( \".\" ) sanitized = sanitized_base_name + extension if not sanitized : raise ValueError ( \"Filename cannot be empty.\" ) return sanitized","title":"MinIO"},{"location":"services/minio/#documentation-for-servicesminiopy","text":"This module provides utilities for interacting with MinIO, including functions for loading models, managing temporary files, converting artwork to base64, and sanitizing filenames.","title":"Documentation for services/minio.py"},{"location":"services/minio/#services.minio.convert_artwork_to_base64","text":"Converts artwork data to a base64-encoded string. Parameters: Name Type Description Default artwork The artwork data. required Returns: Type Description str or None: The base64-encoded string, or None if artwork is None. Source code in services/minio.py 49 50 51 52 53 54 55 56 57 58 59 60 61 def convert_artwork_to_base64 ( artwork ): \"\"\" Converts artwork data to a base64-encoded string. Args: artwork: The artwork data. Returns: str or None: The base64-encoded string, or None if artwork is None. \"\"\" if artwork is not None : return base64 . b64encode ( artwork . data ) . decode ( 'utf-8' ) return None","title":"convert_artwork_to_base64"},{"location":"services/minio/#services.minio.delete_temp_file","text":"Deletes a temporary file. Parameters: Name Type Description Default temp_file_path str The path to the temporary file to delete. required Source code in services/minio.py 40 41 42 43 44 45 46 47 def delete_temp_file ( temp_file_path : str ): \"\"\" Deletes a temporary file. Args: temp_file_path (str): The path to the temporary file to delete. \"\"\" os . unlink ( temp_file_path )","title":"delete_temp_file"},{"location":"services/minio/#services.minio.get_artwork","text":"Retrieves artwork from a specified bucket and file name, converts it to base64. Parameters: Name Type Description Default bucket_name str The name of the bucket. required file_name str The name of the file. required Returns: Type Description str or None: The base64-encoded artwork, or None if not found or an error occurs. Source code in services/minio.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_artwork ( bucket_name : str , file_name : str ): \"\"\" Retrieves artwork from a specified bucket and file name, converts it to base64. Args: bucket_name (str): The name of the bucket. file_name (str): The name of the file. Returns: str or None: The base64-encoded artwork, or None if not found or an error occurs. \"\"\" try : with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : try : data = minio_client . get_object ( bucket_name , file_name ) temp_file . write ( data . read ()) except S3Error as e : if e . code == 'NoSuchKey' : print ( f \"File { file_name } not found in bucket { bucket_name } .\" ) return None else : raise f = music_tag . load_file ( temp_file . name ) if f [ 'artwork' ] and f [ 'artwork' ] . first is not None : return convert_artwork_to_base64 ( f [ 'artwork' ] . first ) return None finally : os . unlink ( temp_file . name )","title":"get_artwork"},{"location":"services/minio/#services.minio.get_metadata_and_artwork","text":"Retrieves metadata and artwork for a given file from MinIO, converting artwork to base64. Parameters: Name Type Description Default bucket_name str The name of the bucket. required file_name str The name of the file. required Returns: Name Type Description dict A dictionary containing the metadata and base64-encoded artwork. Source code in services/minio.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def get_metadata_and_artwork ( bucket_name : str , file_name : str ): \"\"\" Retrieves metadata and artwork for a given file from MinIO, converting artwork to base64. Args: bucket_name (str): The name of the bucket. file_name (str): The name of the file. Returns: dict: A dictionary containing the metadata and base64-encoded artwork. \"\"\" with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : data = minio_client . get_object ( bucket_name , file_name ) temp_file . write ( data . read ()) try : f = music_tag . load_file ( temp_file . name ) metadata = { \"filepath\" : file_name , \"filesize\" : round ( os . path . getsize ( temp_file . name ) / 1024 / 1024 , 2 ), \"title\" : f [ 'title' ] . first or \"Unknown Title\" , \"artist\" : f [ 'artist' ] . first or \"Unknown Artist\" , \"album\" : f [ 'album' ] . first or \"Unknown Album\" , \"year\" : f [ 'year' ] . first or \"Unknown Year\" , \"tracknumber\" : f [ 'tracknumber' ] . first or \"Unknown Track Number\" , \"genre\" : f [ 'genre' ] . first or \"Unknown Genre\" , } if f [ 'artwork' ] and f [ 'artwork' ] . first is not None : metadata [ \"artwork\" ] = convert_artwork_to_base64 ( f [ 'artwork' ] . first ) return metadata finally : os . unlink ( temp_file . name )","title":"get_metadata_and_artwork"},{"location":"services/minio/#services.minio.get_temp_file_from_minio","text":"Retrieves a file from MinIO and writes it to a temporary file. Parameters: Name Type Description Default file_name str The name of the file to retrieve. required Returns: Name Type Description str The path to the temporary file. Source code in services/minio.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_temp_file_from_minio ( file_name : str ): \"\"\" Retrieves a file from MinIO and writes it to a temporary file. Args: file_name (str): The name of the file to retrieve. Returns: str: The path to the temporary file. \"\"\" with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : response = minio_client . get_object ( DEFAULT_SETTINGS . minio_temp_bucket_name , file_name ) temp_file . write ( response . read ()) return temp_file . name","title":"get_temp_file_from_minio"},{"location":"services/minio/#services.minio.load_model_from_minio","text":"Loads a model from MinIO into a temporary file and returns the model. Returns: Name Type Description EmbeddingsOpenL3 The loaded model. Source code in services/minio.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def load_model_from_minio (): \"\"\" Loads a model from MinIO into a temporary file and returns the model. Returns: EmbeddingsOpenL3: The loaded model. \"\"\" with tempfile . NamedTemporaryFile ( delete = False ) as temp_file : response = minio_client . get_object ( DEFAULT_SETTINGS . minio_openl3_bucket_name , DEFAULT_SETTINGS . minio_openl3_file_name ) temp_file . write ( response . read ()) temp_file . flush () embedding_512_model = EmbeddingsOpenL3 ( graph_path = temp_file . name ) return embedding_512_model","title":"load_model_from_minio"},{"location":"services/minio/#services.minio.sanitize_filename","text":"Sanitizes a filename by removing disallowed characters and sequences. Parameters: Name Type Description Default filename str The filename to sanitize. required Returns: Name Type Description str The sanitized filename. Source code in services/minio.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def sanitize_filename ( filename ): \"\"\" Sanitizes a filename by removing disallowed characters and sequences. Args: filename (str): The filename to sanitize. Returns: str: The sanitized filename. \"\"\" replacements = { \"!\" : \"\" , \"@\" : \"\" , \"#\" : \"\" , \"$\" : \"\" , \"%\" : \"\" , \"^\" : \"\" , \"&\" : \"\" , \"*\" : \"\" , \"(\" : \"\" , \")\" : \"\" , \"[\" : \"\" , \"]\" : \"\" , \"{\" : \"\" , \"}\" : \"\" , \";\" : \"\" , \":\" : \"\" , \" \\\" \" : \"\" , \"'\" : \"\" , \",\" : \"\" , \"<\" : \"\" , \">\" : \"\" , \"/\" : \"\" , \"?\" : \"\" , \"`\" : \"\" , \"~\" : \"\" , \"\u00e9\" : \"e\" , \"\u00e8\" : \"e\" , \"\u00ea\" : \"e\" , \"\u00e0\" : \"a\" , \"\u00e2\" : \"a\" , \"\u00f9\" : \"u\" , \"\u00f4\" : \"o\" , \"\u00ee\" : \"i\" , \"\u00e7\" : \"c\" , \"\u00eb\" : \"e\" } has_mp3_extension = filename . lower () . endswith ( '.mp3' ) if has_mp3_extension : base_name , extension = filename [: - 4 ], filename [ - 4 :] else : base_name , extension = filename , '' base_name = base_name . replace ( \"..\" , \"\" ) . replace ( \"//\" , \"\" ) sanitized_base_name = \"\" . join ( replacements . get ( c , c ) for c in base_name if c not in [ ' ' ] and ( c . isalnum () or c in replacements )) if has_mp3_extension : sanitized_base_name = sanitized_base_name . rstrip ( \".\" ) sanitized = sanitized_base_name + extension if not sanitized : raise ValueError ( \"Filename cannot be empty.\" ) return sanitized","title":"sanitize_filename"},{"location":"services/monitoring/","text":"Documentation for services/monitoring.py This module provides functions to monitor various system statistics on a Linux machine, including CPU temperature, CPU usage, memory usage, and disk usage. get_all_pi_stats () Gathers all Raspberry Pi statistics including CPU temperature, CPU usage, memory usage, and disk usage. Returns: Name Type Description dict A dictionary containing all the Raspberry Pi statistics. Source code in services/monitoring.py 53 54 55 56 57 58 59 60 61 62 63 64 65 def get_all_pi_stats (): \"\"\" Gathers all Raspberry Pi statistics including CPU temperature, CPU usage, memory usage, and disk usage. Returns: dict: A dictionary containing all the Raspberry Pi statistics. \"\"\" return { \"cpu_temperature\" : get_pi_cpu_temperature (), \"cpu_usage\" : get_pi_cpu_usage (), \"memory_usage\" : get_pi_memory_usage (), \"disk_usage\" : get_pi_disk_usage () } get_pi_cpu_temperature () Gets the current CPU temperature of the Raspberry Pi. Returns: Name Type Description float The current CPU temperature in degrees Celsius. Source code in services/monitoring.py 3 4 5 6 7 8 9 10 11 12 def get_pi_cpu_temperature (): \"\"\" Gets the current CPU temperature of the Raspberry Pi. Returns: float: The current CPU temperature in degrees Celsius. \"\"\" with open ( '/sys/class/thermal/thermal_zone0/temp' ) as f : temp = f . read () return round ( float ( temp ) / 1000 , 2 ) get_pi_cpu_usage () Calculates the current CPU usage of the Raspberry Pi. Returns: Name Type Description float The current CPU usage as a percentage. Source code in services/monitoring.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def get_pi_cpu_usage (): \"\"\" Calculates the current CPU usage of the Raspberry Pi. Returns: float: The current CPU usage as a percentage. \"\"\" with open ( '/proc/stat' , 'r' ) as f : line = f . readline () stats = line . split () total = sum ( int ( i ) for i in stats [ 1 :]) idle = int ( stats [ 4 ]) usage = (( total - idle ) / total ) * 100 return round ( usage , 2 ) get_pi_disk_usage () Calculates the current disk usage of the Raspberry Pi. Returns: Name Type Description float The current disk usage as a percentage of total disk space. Source code in services/monitoring.py 42 43 44 45 46 47 48 49 50 51 def get_pi_disk_usage (): \"\"\" Calculates the current disk usage of the Raspberry Pi. Returns: float: The current disk usage as a percentage of total disk space. \"\"\" disk = subprocess . check_output ([ 'df' , '-h' , '/' ]) . decode () disk_usage_percentage = disk . split ( ' \\n ' )[ 1 ] . split ()[ 4 ] return float ( disk_usage_percentage . rstrip ( '%' )) get_pi_memory_usage () Calculates the current memory usage of the Raspberry Pi. Returns: Name Type Description float The current memory usage as a percentage of total memory. Source code in services/monitoring.py 29 30 31 32 33 34 35 36 37 38 39 40 def get_pi_memory_usage (): \"\"\" Calculates the current memory usage of the Raspberry Pi. Returns: float: The current memory usage as a percentage of total memory. \"\"\" mem = subprocess . check_output ([ 'cat' , '/proc/meminfo' ]) . decode () total_memory = int ( mem . split ( ' \\n ' )[ 0 ] . split ()[ 1 ]) / 1024 # Convert from KB to MB available_memory = int ( mem . split ( ' \\n ' )[ 2 ] . split ()[ 1 ]) / 1024 # Convert from KB to MB memory_usage_percentage = (( total_memory - available_memory ) / total_memory ) * 100 return round ( memory_usage_percentage , 2 )","title":"Monitoring"},{"location":"services/monitoring/#documentation-for-servicesmonitoringpy","text":"This module provides functions to monitor various system statistics on a Linux machine, including CPU temperature, CPU usage, memory usage, and disk usage.","title":"Documentation for services/monitoring.py"},{"location":"services/monitoring/#services.monitoring.get_all_pi_stats","text":"Gathers all Raspberry Pi statistics including CPU temperature, CPU usage, memory usage, and disk usage. Returns: Name Type Description dict A dictionary containing all the Raspberry Pi statistics. Source code in services/monitoring.py 53 54 55 56 57 58 59 60 61 62 63 64 65 def get_all_pi_stats (): \"\"\" Gathers all Raspberry Pi statistics including CPU temperature, CPU usage, memory usage, and disk usage. Returns: dict: A dictionary containing all the Raspberry Pi statistics. \"\"\" return { \"cpu_temperature\" : get_pi_cpu_temperature (), \"cpu_usage\" : get_pi_cpu_usage (), \"memory_usage\" : get_pi_memory_usage (), \"disk_usage\" : get_pi_disk_usage () }","title":"get_all_pi_stats"},{"location":"services/monitoring/#services.monitoring.get_pi_cpu_temperature","text":"Gets the current CPU temperature of the Raspberry Pi. Returns: Name Type Description float The current CPU temperature in degrees Celsius. Source code in services/monitoring.py 3 4 5 6 7 8 9 10 11 12 def get_pi_cpu_temperature (): \"\"\" Gets the current CPU temperature of the Raspberry Pi. Returns: float: The current CPU temperature in degrees Celsius. \"\"\" with open ( '/sys/class/thermal/thermal_zone0/temp' ) as f : temp = f . read () return round ( float ( temp ) / 1000 , 2 )","title":"get_pi_cpu_temperature"},{"location":"services/monitoring/#services.monitoring.get_pi_cpu_usage","text":"Calculates the current CPU usage of the Raspberry Pi. Returns: Name Type Description float The current CPU usage as a percentage. Source code in services/monitoring.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def get_pi_cpu_usage (): \"\"\" Calculates the current CPU usage of the Raspberry Pi. Returns: float: The current CPU usage as a percentage. \"\"\" with open ( '/proc/stat' , 'r' ) as f : line = f . readline () stats = line . split () total = sum ( int ( i ) for i in stats [ 1 :]) idle = int ( stats [ 4 ]) usage = (( total - idle ) / total ) * 100 return round ( usage , 2 )","title":"get_pi_cpu_usage"},{"location":"services/monitoring/#services.monitoring.get_pi_disk_usage","text":"Calculates the current disk usage of the Raspberry Pi. Returns: Name Type Description float The current disk usage as a percentage of total disk space. Source code in services/monitoring.py 42 43 44 45 46 47 48 49 50 51 def get_pi_disk_usage (): \"\"\" Calculates the current disk usage of the Raspberry Pi. Returns: float: The current disk usage as a percentage of total disk space. \"\"\" disk = subprocess . check_output ([ 'df' , '-h' , '/' ]) . decode () disk_usage_percentage = disk . split ( ' \\n ' )[ 1 ] . split ()[ 4 ] return float ( disk_usage_percentage . rstrip ( '%' ))","title":"get_pi_disk_usage"},{"location":"services/monitoring/#services.monitoring.get_pi_memory_usage","text":"Calculates the current memory usage of the Raspberry Pi. Returns: Name Type Description float The current memory usage as a percentage of total memory. Source code in services/monitoring.py 29 30 31 32 33 34 35 36 37 38 39 40 def get_pi_memory_usage (): \"\"\" Calculates the current memory usage of the Raspberry Pi. Returns: float: The current memory usage as a percentage of total memory. \"\"\" mem = subprocess . check_output ([ 'cat' , '/proc/meminfo' ]) . decode () total_memory = int ( mem . split ( ' \\n ' )[ 0 ] . split ()[ 1 ]) / 1024 # Convert from KB to MB available_memory = int ( mem . split ( ' \\n ' )[ 2 ] . split ()[ 1 ]) / 1024 # Convert from KB to MB memory_usage_percentage = (( total_memory - available_memory ) / total_memory ) * 100 return round ( memory_usage_percentage , 2 )","title":"get_pi_memory_usage"},{"location":"services/openl3/","text":"Documentation for services/openl3.py This module is designed to extract audio embeddings using the OpenL3 model. It handles the extraction of embeddings from audio files stored in MinIO. extract_embeddings ( file_path ) Extracts embeddings from an audio file using the OpenL3 model. Parameters: Name Type Description Default file_path str The path to the audio file from which to extract embeddings. required Returns: Name Type Description list A list representing the extracted embeddings. Raises: Type Description Exception If the file cannot be found or an error occurs during the embedding extraction process. Source code in services/openl3.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def extract_embeddings ( file_path : str ): \"\"\" Extracts embeddings from an audio file using the OpenL3 model. Args: file_path (str): The path to the audio file from which to extract embeddings. Returns: list: A list representing the extracted embeddings. Raises: Exception: If the file cannot be found or an error occurs during the embedding extraction process. \"\"\" try : # Load the OpenL3 model from MinIO embedding_512_model = load_model_from_minio () # Obtain a temporary file path for the audio file from MinIO temp_file_path = get_temp_file_from_minio ( DEFAULT_SETTINGS . minio_openl3_bucket_name , file_path ) # Compute embeddings using the temporary file path vector = embedding_512_model . compute ( temp_file_path ) embedding = vector . mean ( axis = 0 ) # Clean up the temporary file os . unlink ( temp_file_path ) return embedding . tolist () except Exception as e : raise Exception ( f \"File not found: { e } \" )","title":"OpenL3"},{"location":"services/openl3/#documentation-for-servicesopenl3py","text":"This module is designed to extract audio embeddings using the OpenL3 model. It handles the extraction of embeddings from audio files stored in MinIO.","title":"Documentation for services/openl3.py"},{"location":"services/openl3/#services.openl3.extract_embeddings","text":"Extracts embeddings from an audio file using the OpenL3 model. Parameters: Name Type Description Default file_path str The path to the audio file from which to extract embeddings. required Returns: Name Type Description list A list representing the extracted embeddings. Raises: Type Description Exception If the file cannot be found or an error occurs during the embedding extraction process. Source code in services/openl3.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def extract_embeddings ( file_path : str ): \"\"\" Extracts embeddings from an audio file using the OpenL3 model. Args: file_path (str): The path to the audio file from which to extract embeddings. Returns: list: A list representing the extracted embeddings. Raises: Exception: If the file cannot be found or an error occurs during the embedding extraction process. \"\"\" try : # Load the OpenL3 model from MinIO embedding_512_model = load_model_from_minio () # Obtain a temporary file path for the audio file from MinIO temp_file_path = get_temp_file_from_minio ( DEFAULT_SETTINGS . minio_openl3_bucket_name , file_path ) # Compute embeddings using the temporary file path vector = embedding_512_model . compute ( temp_file_path ) embedding = vector . mean ( axis = 0 ) # Clean up the temporary file os . unlink ( temp_file_path ) return embedding . tolist () except Exception as e : raise Exception ( f \"File not found: { e } \" )","title":"extract_embeddings"},{"location":"services/spotinite/","text":"Documentation for services/spotinite.py This module integrates the Spotify Web API through the Spotipy client and the Cyanite.ai API to provide functionalities such as searching for a track by name and artist, fetching similar tracks based on a Spotify track ID, and retrieving detailed information about a track. It is designed to facilitate the exploration and recommendation of music tracks by leveraging the capabilities of both Spotify and Cyanite.ai services. fetch_similar_tracks ( spotify_id ) Fetches similar tracks from the Cyanite.ai API based on a given Spotify track ID. Parameters: Name Type Description Default spotify_id str The Spotify ID of the track for which similar tracks are to be found. required Returns: Name Type Description list list A list of Spotify IDs for tracks similar to the given track. Source code in services/spotinite.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def fetch_similar_tracks ( spotify_id : str ) -> list : \"\"\" Fetches similar tracks from the Cyanite.ai API based on a given Spotify track ID. Args: spotify_id (str): The Spotify ID of the track for which similar tracks are to be found. Returns: list: A list of Spotify IDs for tracks similar to the given track. \"\"\" url = \"https://api.cyanite.ai/graphql\" headers = { \"Content-Type\" : \"application/json\" , \"Authorization\" : f \"Bearer { DEFAULT_SETTINGS . cyanite_token } \" , } query = \"\"\" query SimilarTracksQuery($trackId: ID!) { spotifyTrack(id: $trackId) { __typename ... on Error { message } ... on Track { id similarTracks(target: { spotify: {} }, first: 15) { __typename ... on SimilarTracksError { code message } ... on SimilarTracksConnection { edges { node { id } } } } } } } \"\"\" variables = { \"trackId\" : spotify_id } response = requests . post ( url , headers = headers , json = { \"query\" : query , \"variables\" : variables }) data = response . json () if 'edges' in data [ 'data' ][ 'spotifyTrack' ][ 'similarTracks' ]: edges = data [ 'data' ][ 'spotifyTrack' ][ 'similarTracks' ][ 'edges' ] track_ids = [ edge [ 'node' ][ 'id' ] for edge in edges ] return track_ids else : return [] get_track_id ( song_name , artist ) Searches for a song on Spotify by name and artist and returns the Spotify ID of the first result. Parameters: Name Type Description Default song_name str The name of the song. required artist str The name of the artist. required Returns: Name Type Description str str The Spotify ID of the song. Source code in services/spotinite.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def get_track_id ( song_name : str , artist : str ) -> str : \"\"\" Searches for a song on Spotify by name and artist and returns the Spotify ID of the first result. Args: song_name (str): The name of the song. artist (str): The name of the artist. Returns: str: The Spotify ID of the song. \"\"\" results = sp . search ( q = f 'track: { song_name } artist: { artist } ' , type = 'track' ) spotify_id = results [ 'tracks' ][ 'items' ][ 0 ][ 'id' ] return spotify_id get_track_info ( track_id ) Retrieves detailed information about a track from Spotify using its Spotify ID. Parameters: Name Type Description Default track_id str The Spotify ID of the track. required Returns: Name Type Description dict dict A dictionary containing detailed information about the track, including its name, artist, album, URI, and cover image URL. Source code in services/spotinite.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_track_info ( track_id : str ) -> dict : \"\"\" Retrieves detailed information about a track from Spotify using its Spotify ID. Args: track_id (str): The Spotify ID of the track. Returns: dict: A dictionary containing detailed information about the track, including its name, artist, album, URI, and cover image URL. \"\"\" track_info = sp . track ( track_id ) track_name = track_info [ 'name' ] artist_name = track_info [ 'artists' ][ 0 ][ 'name' ] album_name = track_info [ 'album' ][ 'name' ] uri = track_info [ 'uri' ] cover_image = track_info [ 'album' ][ 'images' ][ 0 ][ 'url' ] return { \"Track Name\" : track_name , \"Artist\" : artist_name , \"Album\" : album_name , \"URI\" : uri , \"Cover Image\" : cover_image }","title":"Spotinite"},{"location":"services/spotinite/#documentation-for-servicesspotinitepy","text":"This module integrates the Spotify Web API through the Spotipy client and the Cyanite.ai API to provide functionalities such as searching for a track by name and artist, fetching similar tracks based on a Spotify track ID, and retrieving detailed information about a track. It is designed to facilitate the exploration and recommendation of music tracks by leveraging the capabilities of both Spotify and Cyanite.ai services.","title":"Documentation for services/spotinite.py"},{"location":"services/spotinite/#services.spotinite.fetch_similar_tracks","text":"Fetches similar tracks from the Cyanite.ai API based on a given Spotify track ID. Parameters: Name Type Description Default spotify_id str The Spotify ID of the track for which similar tracks are to be found. required Returns: Name Type Description list list A list of Spotify IDs for tracks similar to the given track. Source code in services/spotinite.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def fetch_similar_tracks ( spotify_id : str ) -> list : \"\"\" Fetches similar tracks from the Cyanite.ai API based on a given Spotify track ID. Args: spotify_id (str): The Spotify ID of the track for which similar tracks are to be found. Returns: list: A list of Spotify IDs for tracks similar to the given track. \"\"\" url = \"https://api.cyanite.ai/graphql\" headers = { \"Content-Type\" : \"application/json\" , \"Authorization\" : f \"Bearer { DEFAULT_SETTINGS . cyanite_token } \" , } query = \"\"\" query SimilarTracksQuery($trackId: ID!) { spotifyTrack(id: $trackId) { __typename ... on Error { message } ... on Track { id similarTracks(target: { spotify: {} }, first: 15) { __typename ... on SimilarTracksError { code message } ... on SimilarTracksConnection { edges { node { id } } } } } } } \"\"\" variables = { \"trackId\" : spotify_id } response = requests . post ( url , headers = headers , json = { \"query\" : query , \"variables\" : variables }) data = response . json () if 'edges' in data [ 'data' ][ 'spotifyTrack' ][ 'similarTracks' ]: edges = data [ 'data' ][ 'spotifyTrack' ][ 'similarTracks' ][ 'edges' ] track_ids = [ edge [ 'node' ][ 'id' ] for edge in edges ] return track_ids else : return []","title":"fetch_similar_tracks"},{"location":"services/spotinite/#services.spotinite.get_track_id","text":"Searches for a song on Spotify by name and artist and returns the Spotify ID of the first result. Parameters: Name Type Description Default song_name str The name of the song. required artist str The name of the artist. required Returns: Name Type Description str str The Spotify ID of the song. Source code in services/spotinite.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def get_track_id ( song_name : str , artist : str ) -> str : \"\"\" Searches for a song on Spotify by name and artist and returns the Spotify ID of the first result. Args: song_name (str): The name of the song. artist (str): The name of the artist. Returns: str: The Spotify ID of the song. \"\"\" results = sp . search ( q = f 'track: { song_name } artist: { artist } ' , type = 'track' ) spotify_id = results [ 'tracks' ][ 'items' ][ 0 ][ 'id' ] return spotify_id","title":"get_track_id"},{"location":"services/spotinite/#services.spotinite.get_track_info","text":"Retrieves detailed information about a track from Spotify using its Spotify ID. Parameters: Name Type Description Default track_id str The Spotify ID of the track. required Returns: Name Type Description dict dict A dictionary containing detailed information about the track, including its name, artist, album, URI, and cover image URL. Source code in services/spotinite.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_track_info ( track_id : str ) -> dict : \"\"\" Retrieves detailed information about a track from Spotify using its Spotify ID. Args: track_id (str): The Spotify ID of the track. Returns: dict: A dictionary containing detailed information about the track, including its name, artist, album, URI, and cover image URL. \"\"\" track_info = sp . track ( track_id ) track_name = track_info [ 'name' ] artist_name = track_info [ 'artists' ][ 0 ][ 'name' ] album_name = track_info [ 'album' ][ 'name' ] uri = track_info [ 'uri' ] cover_image = track_info [ 'album' ][ 'images' ][ 0 ][ 'url' ] return { \"Track Name\" : track_name , \"Artist\" : artist_name , \"Album\" : album_name , \"URI\" : uri , \"Cover Image\" : cover_image }","title":"get_track_info"},{"location":"services/uploaded/","text":"Documentation for services/uploaded.py This module provides functionalities to interact with a MiniO bucket for storing and retrieving user uploaded songs. get_user_uploads ( db , user_id ) Retrieves all files uploaded by a specific user. Parameters: Name Type Description Default db Session The SQLAlchemy session object. required user_id int The ID of the user whose uploads are to be retrieved. required Returns: Type Description list[dict]: A list of dictionaries, each containing the filename of an uploaded file. Source code in services/uploaded.py 25 26 27 28 29 30 31 32 33 34 35 36 37 def get_user_uploads ( db : Session , user_id : int ): \"\"\" Retrieves all files uploaded by a specific user. Args: db (Session): The SQLAlchemy session object. user_id (int): The ID of the user whose uploads are to be retrieved. Returns: list[dict]: A list of dictionaries, each containing the filename of an uploaded file. \"\"\" uploaded_files = db . query ( UserUploaded ) . filter ( UserUploaded . user_id == user_id ) . all () return [{ \"filename\" : file . filename } for file in uploaded_files ] store_upload_info ( db , user_id , filename ) Stores information about a file uploaded by a user in the database if it does not already exist. Parameters: Name Type Description Default db Session The SQLAlchemy session object. required user_id int The ID of the user who uploaded the file. required filename str The name of the uploaded file. required This function checks if an entry with the given user ID and filename already exists in the database. If not, it creates a new entry and commits it to the database. Source code in services/uploaded.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def store_upload_info ( db : Session , user_id : int , filename : str ): \"\"\" Stores information about a file uploaded by a user in the database if it does not already exist. Args: db (Session): The SQLAlchemy session object. user_id (int): The ID of the user who uploaded the file. filename (str): The name of the uploaded file. This function checks if an entry with the given user ID and filename already exists in the database. If not, it creates a new entry and commits it to the database. \"\"\" existing_entry = db . query ( UserUploaded ) . filter_by ( user_id = user_id , filename = filename ) . first () if not existing_entry : upload_entry = UserUploaded ( user_id = user_id , filename = filename ) db . add ( upload_entry ) db . commit ()","title":"Uploaded"},{"location":"services/uploaded/#documentation-for-servicesuploadedpy","text":"This module provides functionalities to interact with a MiniO bucket for storing and retrieving user uploaded songs.","title":"Documentation for services/uploaded.py"},{"location":"services/uploaded/#services.uploaded.get_user_uploads","text":"Retrieves all files uploaded by a specific user. Parameters: Name Type Description Default db Session The SQLAlchemy session object. required user_id int The ID of the user whose uploads are to be retrieved. required Returns: Type Description list[dict]: A list of dictionaries, each containing the filename of an uploaded file. Source code in services/uploaded.py 25 26 27 28 29 30 31 32 33 34 35 36 37 def get_user_uploads ( db : Session , user_id : int ): \"\"\" Retrieves all files uploaded by a specific user. Args: db (Session): The SQLAlchemy session object. user_id (int): The ID of the user whose uploads are to be retrieved. Returns: list[dict]: A list of dictionaries, each containing the filename of an uploaded file. \"\"\" uploaded_files = db . query ( UserUploaded ) . filter ( UserUploaded . user_id == user_id ) . all () return [{ \"filename\" : file . filename } for file in uploaded_files ]","title":"get_user_uploads"},{"location":"services/uploaded/#services.uploaded.store_upload_info","text":"Stores information about a file uploaded by a user in the database if it does not already exist. Parameters: Name Type Description Default db Session The SQLAlchemy session object. required user_id int The ID of the user who uploaded the file. required filename str The name of the uploaded file. required This function checks if an entry with the given user ID and filename already exists in the database. If not, it creates a new entry and commits it to the database. Source code in services/uploaded.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def store_upload_info ( db : Session , user_id : int , filename : str ): \"\"\" Stores information about a file uploaded by a user in the database if it does not already exist. Args: db (Session): The SQLAlchemy session object. user_id (int): The ID of the user who uploaded the file. filename (str): The name of the uploaded file. This function checks if an entry with the given user ID and filename already exists in the database. If not, it creates a new entry and commits it to the database. \"\"\" existing_entry = db . query ( UserUploaded ) . filter_by ( user_id = user_id , filename = filename ) . first () if not existing_entry : upload_entry = UserUploaded ( user_id = user_id , filename = filename ) db . add ( upload_entry ) db . commit ()","title":"store_upload_info"}]}